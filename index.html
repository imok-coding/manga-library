<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, maximum-scale=1.0, user-scalable=no">
      <!-- Social sharing preview -->
      <meta name="description" content="Browse Tyler's Manga Library and wishlist with covers, release tracking, and reading stats.">
      <meta property="og:type" content="website">
      <meta property="og:title" content="Tyler's Manga Library">
      <meta property="og:description" content="Browse Tyler's Manga Library and wishlist with covers, release tracking, and reading stats.">
      <meta property="og:image" content="https://tyler-manga-library.example.com/book-preview.png">
      <meta property="og:url" content="https://tyler-manga-library.example.com/">
      <meta name="twitter:card" content="summary_large_image">
      <meta name="twitter:title" content="Tyler's Manga Library">
      <meta name="twitter:description" content="Browse Tyler's Manga Library and wishlist with covers, release tracking, and reading stats.">
      <meta name="twitter:image" content="https://tyler-manga-library.example.com/book-preview.png">
      <meta name="theme-color" content="#1e0d14">
      <title>Tyler's Manga Library</title>
      <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
      <style>
         /* ===== BODY & BASE ===== */
         body {
         background: #1e0d14;
         color: #fff;
         font-family: Helvetica, Arial, sans-serif;
         margin: 0;
         padding: 0;
         }
         html {
         scroll-behavior: smooth;
         }
         .container {
         max-width: 1200px;
         margin: 0 auto;
         padding: 20px;
         position: relative;
         overflow: hidden;
         }
         h1 {
         text-align: center;
         color: #ffb6c1;
         margin-top: 10px;
         text-shadow: 0 0 6px rgba(255,182,193,0.7);
         }
         /* ===== HAMBURGER MENU ===== */
         .menu-toggle {
         position: fixed;
         top: 16px;
         left: 16px;
         width: 32px;
         height: 26px;
         display: flex;
         flex-direction: column;
         justify-content: center;
         gap: 6px;
         background: transparent;
         border: none;
         border-radius: 10px;
         padding: 0;
         cursor: pointer;
         z-index: 11000;
         outline: none;
         appearance: none;
         -webkit-appearance: none;
         box-shadow: none;
         }
         .menu-toggle:focus-visible {
         outline: 1px solid #ffb6c1;
         box-shadow: 0 0 6px rgba(255,182,193,0.6);
         }
         .menu-toggle span {
         display: block;
         width: 100%;
         height: 4px;
         border-radius: 4px;
         background: #ffb6c1;
         transition: transform 0.2s, opacity 0.2s;
         }
         .menu-toggle.active span:nth-child(1) {
         transform: translateY(10px) rotate(45deg);
         }
         .menu-toggle.active span:nth-child(2) {
         opacity: 0;
         }
         .menu-toggle.active span:nth-child(3) {
         transform: translateY(-10px) rotate(-45deg);
         }
         /* On mobile, move button to the right */
         @media (max-width: 600px) {
         .menu-toggle {
         left: auto;
         right: 16px;
         }
         }
         /* Slide-in side menu */
         .menu-panel {
         position: fixed;
         top: 0;
         left: 0;
         height: 100%;
         width: 220px;
         background: #2b0f1d;
         box-shadow: 4px 0 16px rgba(0,0,0,0.6);
         padding: 60px 0 16px;
         display: flex;
         flex-direction: column;
         justify-content: flex-start;
         transform: translateX(-100%);
         transition: transform 0.25s ease;
         z-index: 10999;
         }
         /* menu items area */
         .menu-items {
         display: flex;
         flex-direction: column;
         gap: 4px;
         padding-bottom: 8px;
         }
         .menu-panel.open {
         transform: translateX(0);
         }
         .menu-item {
         width: 100%;
         background: transparent;
         border: none;
         color: #ffb6c1;
         padding: 10px 20px;
         text-align: left;
         font-size: 15px;
         cursor: pointer;
         }
         .menu-item:hover {
         background: rgba(255,182,193,0.18);
         }
         /* Auth section is at the bottom of panel */
         .auth-section {
         padding: 10px 16px 16px;
         border-top: 1px solid rgba(255,182,193,0.25);
         font-size: 12px;
         color: #f8d1d8;
         display: flex;
         flex-direction: column;
         gap: 6px;
         }
         .auth-section-status {
         margin: 0 0 2px;
         }
         #menuDashboard {
         margin: 0 0 6px;
         text-align: left;
         }
         .auth-btn {
         padding: 4px 10px;
         border-radius: 6px;
         border: none;
         cursor: pointer;
         font-size: 12px;
         margin-right: 6px;
         background: #ffb6c1;
         color: #2b0f1d;
         }
         .auth-btn.secondary {
         background: #2b0f1d;
         color: #ffb6c1;
         border: 1px solid #ffb6c1;
         }
         /* For mobile, slide in from the right instead */
         @media (max-width: 600px) {
         .menu-panel {
         left: auto;
         right: 0;
         box-shadow: -4px 0 16px rgba(0,0,0,0.6);
         transform: translateX(100%);
         }
         .menu-panel.open {
         transform: translateX(0);
         }
         .menu-panel {
         width: 80%;
         max-width: 320px;
         }
         }
         /* ===== COUNTERS ===== */
         .counter {
         display: flex;
         justify-content: center;
         gap: 20px;
         font-size: 14px;
         color: #f8f0f4;
         margin: 10px 0;
         }
         .counter span {
         padding: 4px 12px;
         border-radius: 12px;
         font-weight: 600;
         background: rgba(255,182,193,0.1);
         color: #ffb6c1;
         transition: 0.2s;
         }
         .counter span:hover {
         background: rgba(255,182,193,0.25);
         cursor: pointer;
         }
         /* ===== SEARCH INPUTS ===== */
         #searchInput, #wishlistSearchInput {
         width: 90%;
         max-width: 500px;
         margin: 12px auto;
         display: block;
         padding: 10px;
         font-size: 14px;
         border-radius: 8px;
         border: 1px solid #bb7f8f;
         background: #2b0f1d;
         color: #fff;
         box-shadow: 0 0 6px rgba(255,182,193,0.3) inset;
         }
         /* ===== WISHLIST HEADER & COUNTDOWN ===== */
         #wishlistHeader {
         display: flex;
         flex-direction: column;
         align-items: center;
         gap: 6px;
         }
         #wishlistCountdown {
         display: none;
         padding: 12px 16px;
         background: linear-gradient(135deg, rgba(255,182,193,0.18), rgba(255,105,180,0.18));
         border: 1px solid rgba(255,182,193,0.35);
         border-radius: 12px;
         box-shadow: 0 6px 18px rgba(255,182,193,0.3);
         text-align: center;
         }
         #wishlistCountdown .countdown-label {
         font-size: 11px;
         letter-spacing: 0.8px;
         text-transform: uppercase;
         color: #f8d1d8;
         margin-bottom: 4px;
         }
         #wishlistCountdownTitle {
         font-size: 16px;
         font-weight: 700;
         color: #ffb6c1;
         margin-bottom: 6px;
         }
         #wishlistCountdownTimer {
         font-size: 19px;
         font-weight: 700;
         color: #ffffff;
         letter-spacing: 1px;
         }
         #wishlistCountdownDate {
         font-size: 12px;
         color: #f8d1d8;
         opacity: 0.85;
         margin-top: 2px;
         }
         /* ===== DASHBOARD ===== */
         #dashboardSection {
         padding-top: 10px;
         }
         .settings-icon-btn {
         width: 34px;
         height: 34px;
         border-radius: 50%;
         border: 1px solid #ff69b4;
         background: transparent;
         color: #ffb6c1;
         cursor: pointer;
         box-shadow: none;
         font-size: 16px;
         transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
         margin-left: auto;
         }
         .settings-icon-btn:hover {
         transform: scale(1.05);
         background: rgba(255,105,180,0.15);
         }
         .dashboard-grid {
         display: grid;
         grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
         gap: 14px;
         padding: 10px;
         max-width: 1100px;
         margin: 0 auto;
         }
         .stat-card {
         background: #2b0f1d;
         border: 1px solid rgba(255,182,193,0.25);
         border-radius: 14px;
         padding: 12px;
         box-shadow: 0 2px 12px rgba(255,182,193,0.18);
         display: flex;
         flex-direction: column;
         gap: 6px;
         align-items: center;
         transition: transform 0.2s ease, box-shadow 0.3s ease;
         }
         .stat-card.wide {
         grid-column: 1 / -1;
         align-items: stretch;
         padding: 16px;
         overflow: hidden;
         }
         .stat-card.wide-2 {
         grid-column: span 2;
         }
         @media (max-width: 900px) {
         .stat-card.wide-2 {
         grid-column: 1 / -1;
         }
         }
         .stat-card.tall {
         min-height: 200px;
         }
         .stat-stack {
         display: grid;
         grid-template-rows: repeat(2, auto);
         gap: 10px;
         }
         .stat-card:hover {
         transform: translateY(-6px);
         box-shadow: 0 10px 24px rgba(255,182,193,0.28);
         }
         .stat-duo {
         display: grid;
         grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
         gap: 14px;
         grid-column: 1 / -1;
         }
         .calendar-header {
         display: flex;
         align-items: center;
         justify-content: space-between;
         gap: 8px;
         margin-bottom: 8px;
         }
         .calendar-title {
         font-size: 14px;
         font-weight: 700;
         color: #ffb6c1;
         }
         .calendar-nav {
         display: flex;
         gap: 6px;
         }
         .calendar-nav-btn {
         width: 30px;
         height: 30px;
         border-radius: 8px;
         border: 1px solid #ff69b4;
         background: transparent;
         color: #ffb6c1;
         cursor: pointer;
         font-weight: 700;
         box-shadow: none;
         }
         .calendar-nav-btn:hover {
         background: rgba(255,105,180,0.15);
         }
         .calendar-weekdays {
         display: grid;
         grid-template-columns: repeat(7, 1fr);
         gap: 6px;
         margin-bottom: 6px;
         font-size: 11px;
         color: #f8d1d8;
         text-align: center;
         letter-spacing: 0.4px;
         }
         .calendar-grid {
         display: grid;
         grid-template-columns: repeat(7, 1fr);
         gap: 6px;
         }
         .calendar-day {
         min-height: 62px;
         border: 1px solid rgba(255,182,193,0.25);
         border-radius: 10px;
         padding: 6px;
         background: rgba(43,15,29,0.6);
         display: flex;
         flex-direction: column;
         gap: 4px;
         }
         .calendar-day.pad {
         opacity: 0.4;
         border-style: dashed;
         }
         .calendar-day .day-num {
         font-size: 11px;
         color: #f8d1d8;
         }
         .calendar-release {
         background: rgba(255,105,180,0.15);
         border: 1px solid rgba(255,105,180,0.35);
         border-radius: 8px;
         padding: 4px 6px;
         font-size: 11px;
         color: #ffb6c1;
         line-height: 1.3;
         }
         .calendar-empty {
         font-size: 12px;
         color: #f8d1d8;
         text-align: center;
         margin-top: 6px;
         opacity: 0.8;
         }
         .stat-card h3 {
         margin: 0 0 2px;
         font-size: 13px;
         color: #ffb6c1;
         text-align: center;
         }
         .stat-card .stat-value {
         font-size: 20px;
         font-weight: 700;
         color: #fff;
         text-align: center;
         }
         .stat-card.mini {
         padding: 10px;
         gap: 4px;
         }
         .stat-card.mini h3 {
         font-size: 12px;
         margin-bottom: 2px;
         }
         .stat-card.mini .stat-value {
         font-size: 18px;
         }
         .stat-card .stat-value.next-release {
         font-size: 16px;
         line-height: 1.3;
         }
         .stat-sub {
         font-size: 12px;
         color: #f8d1d8;
         text-align: center;
         }
         #statNextCountdown {
         font-size: 14px;
         font-weight: 700;
         color: #ffb6c1;
         }
         #statCollectionValue {
         color: #00e676;
         text-shadow: 0 0 6px rgba(0,230,118,0.6);
         }
         .pie {
         width: 130px;
         height: 130px;
         border-radius: 50%;
         background: conic-gradient(#ff69b4 calc(var(--pct,0) * 1%), rgba(255,255,255,0.12) 0);
         display: grid;
         place-items: center;
         position: relative;
         transition: background 0.6s ease, transform 0.2s ease, box-shadow 0.3s ease;
         overflow: hidden;
         }
         .pie::after {
         content: '';
         position: absolute;
         inset: 16px;
         background: #1e0d14;
         border-radius: 50%;
         z-index: 1;
         }
         .pie::before {
         content: attr(data-label);
         position: absolute;
         inset: 10px;
         display: flex;
         align-items: center;
         justify-content: center;
         text-align: center;
         font-size: 12px;
         font-weight: 600;
         color: #fff;
         background: rgba(43,15,29,0.92);
         border: 1px solid rgba(255,182,193,0.35);
         border-radius: 10px;
         padding: 6px;
         line-height: 1.35;
         display: none; /* hide hover box inside pies */
         }
         .stat-card:hover .pie {
         transform: scale(1.05);
         box-shadow: 0 0 18px rgba(255,105,180,0.4);
         }
         .pie:hover::before {
         opacity: 1;
         }
         .pie-label {
         position: absolute;
         inset: 0;
         display: flex;
         align-items: center;
         justify-content: center;
         font-size: 16px;
         font-weight: 700;
         color: #fff;
         text-shadow: 0 0 6px rgba(30,13,20,0.9);
         pointer-events: none;
         z-index: 2;
         }
         .bar-chart {
         display: flex;
         align-items: flex-end;
         justify-content: space-between;
         gap: 10px;
         width: 100%;
         min-height: 180px;
         height: 200px;
         padding: 10px 10px 0;
         }
         .bar {
         flex: 1;
         display: flex;
         flex-direction: column;
         align-items: center;
         justify-content: flex-end;
         height: 100%;
         gap: 4px;
         }
         .bar .bar-fill {
         width: 100%;
         max-width: 20px;
         border-radius: 10px 10px 4px 4px;
         background: linear-gradient(180deg, #ff69b4 0%, #c2185b 100%);
         box-shadow: 0 4px 12px rgba(255,105,180,0.4);
         transition: height 0.35s ease, transform 0.2s ease;
         }
         .bar:hover .bar-fill {
         transform: translateY(-3px);
         }
         .bar .bar-value {
         font-size: 11px;
         color: #ffb6c1;
         }
         .bar .bar-label {
         font-size: 10px;
         color: #f8d1d8;
         letter-spacing: 0.4px;
         text-transform: uppercase;
         }
         .stat-list {
         display: flex;
         flex-direction: column;
         gap: 6px;
         width: 100%;
         }
         .stat-list-row {
         display: flex;
         align-items: center;
         justify-content: space-between;
         padding: 6px 8px;
         background: rgba(255,182,193,0.08);
         border: 1px solid rgba(255,182,193,0.2);
         border-radius: 8px;
         font-size: 12px;
         color: #f8d1d8;
         }
         .stat-list-row .stat-rank {
         color: #ffb6c1;
         font-weight: 700;
         margin-right: 6px;
         }
         .stat-list-row .stat-name {
         flex: 1;
         text-align: left;
         }
         .stat-list-row .stat-count {
         color: #fff;
         font-weight: 700;
         }
         .line-chart {
         position: relative;
         width: 100%;
         height: 200px;
         padding: 6px 10px 18px; /* give room for angled month labels */
         }
         .line-chart svg {
         width: 100%;
         height: 100%;
         overflow: visible;
         }
         .line-grid {
         stroke: rgba(255,255,255,0.08);
         stroke-width: 0.5;
         }
         .line-path {
         fill: none;
         stroke: #ff69b4;
         stroke-width: 2;
         filter: drop-shadow(0 2px 6px rgba(255,105,180,0.4));
         }
         .line-point {
         fill: #ff69b4;
         stroke: #2b0f1d;
         stroke-width: 1.2;
         }
         .line-label {
         font-size: 8px;
         fill: #f8d1d8;
         text-anchor: middle;
         }
         .line-value {
         font-size: 10px;
         font-weight: 700;
         fill: #ffb6c1;
         text-anchor: middle;
         paint-order: stroke fill;
         stroke: #000000;
         stroke-width: 1.2;
         }
         /* Activity log */
         .activity-log {
         width: 100%;
         max-height: 240px;
         overflow-y: auto;
         display: flex;
         flex-direction: column;
         gap: 6px;
         }
         .activity-item {
         background: rgba(255,182,193,0.08);
         border: 1px solid rgba(255,182,193,0.2);
         border-radius: 8px;
         padding: 6px 8px;
         font-size: 12px;
         color: #f8d1d8;
         display: flex;
         justify-content: space-between;
         gap: 10px;
         }
         .activity-text {
         flex: 1;
         text-align: left;
         }
         .activity-time {
         color: #eea4b7;
         white-space: nowrap;
         font-size: 11px;
         }
         .activity-empty {
         color: #f8d1d8;
         opacity: 0.8;
         font-size: 12px;
         text-align: center;
         padding: 6px 0;
         }
         /* Settings popup */
         #settingsOverlay {
         position: fixed;
         inset: 0;
         background: rgba(30,13,20,0.92);
         backdrop-filter: blur(6px);
         display: none;
         justify-content: center;
         align-items: center;
         z-index: 10060;
         }
         #settingsCard {
         background: #2b0f1d;
         border-radius: 14px;
         padding: 16px;
         width: 90%;
         max-width: 360px;
         box-shadow: 0 0 24px rgba(255,182,193,0.6);
         position: relative;
         color: #fff;
         }
         #settingsClose {
         position: absolute;
         top: 10px;
         right: 10px;
         background: rgba(255,255,255,0.08);
         border: 1px solid rgba(255,255,255,0.2);
         color: #fff;
         border-radius: 6px;
         width: 28px;
         height: 28px;
         cursor: pointer;
         font-size: 18px;
         }
         .settings-title {
         margin: 0 0 10px;
         color: #ffb6c1;
         text-align: center;
         }
         .settings-actions {
         display: flex;
         flex-direction: column;
         gap: 8px;
         }
         .settings-btn {
         padding: 10px 12px;
         border-radius: 10px;
         border: 1px solid rgba(255,182,193,0.35);
         background: rgba(255,182,193,0.1);
         color: #fff;
         cursor: pointer;
         font-weight: 600;
         }
         .settings-btn:hover {
         background: rgba(255,182,193,0.2);
         }
         /* Dashboard library list */
         .dash-library {
         display: grid;
         grid-template-columns: 1fr 1fr;
         gap: 12px;
         width: 100%;
         align-items: stretch;
         box-sizing: border-box;
         padding: 4px;
         }
         .dash-library-list,
         .dash-library-details {
         min-height: 380px;
         height: 100%;
         box-sizing: border-box;
         }
         .dash-library-list {
         overflow-y: auto;
         border: 1px solid rgba(255,182,193,0.25);
         border-radius: 10px;
         padding: 8px;
         background: rgba(43,15,29,0.5);
         }
         .dash-series {
         margin-bottom: 8px;
         }
         .dash-series-header {
         width: 100%;
         text-align: left;
         background: transparent;
         border: 1px solid rgba(255,182,193,0.25);
         color: #ffb6c1;
         padding: 8px;
         border-radius: 8px;
         cursor: pointer;
         display: flex;
         align-items: center;
         justify-content: space-between;
         gap: 8px;
         }
         .dash-series-header .dash-series-title {
         flex: 1;
         }
         .dash-series-header .dash-series-meta {
         font-size: 11px;
         color: #f8d1d8;
         }
         .dash-series-header .dash-series-chevron {
         transition: transform 0.2s ease;
         }
         .dash-series.expanded .dash-series-chevron {
         transform: rotate(90deg);
         }
         .dash-series-header.active {
         border-color: #ff69b4;
         box-shadow: 0 0 8px rgba(255,105,180,0.5);
         }
         .dash-series-books {
         margin: 6px 0 10px 10px;
         padding-left: 10px;
         border-left: 1px solid rgba(255,182,193,0.25);
         display: none;
         }
         .dash-series.expanded .dash-series-books {
         display: block;
         }
         .dash-series-books button {
         width: 100%;
         text-align: left;
         background: transparent;
         border: 1px solid rgba(255,182,193,0.25);
         color: #ffb6c1;
         padding: 8px;
         border-radius: 8px;
         margin-bottom: 6px;
         cursor: pointer;
         }
         .dash-series-books button.active {
         border-color: #ff69b4;
         box-shadow: 0 0 8px rgba(255,105,180,0.5);
         }
         .dash-library-details {
         border: 1px solid rgba(255,182,193,0.25);
         border-radius: 10px;
         padding: 12px;
         background: rgba(43,15,29,0.6);
         display: flex;
         flex-direction: column;
         }
         .dash-detail-title {
         margin: 0 0 8px;
         color: #ffb6c1;
         font-size: 15px;
         }
         .dash-detail-row {
         margin-bottom: 8px;
         display: flex;
         flex-direction: column;
         color: #f8d1d8;
         font-size: 12px;
         }
         .dash-detail-row select {
         min-height: 34px;
         }
         .dash-detail-row input[type="checkbox"] {
         margin-right: 6px;
         }
         .dash-detail-actions {
         display: flex;
         justify-content: flex-end;
         gap: 8px;
         }
         .dash-btn {
         padding: 6px 12px;
         border-radius: 999px;
         border: none;
         cursor: pointer;
         font-weight: 600;
         }
         .dash-btn.primary {
         background: #ff69b4;
         color: #1e0d14;
         }
         .dash-btn.secondary {
         background: transparent;
         border: 1px solid #ffb6c1;
         color: #ffb6c1;
         }
         /* ===== ADMIN PANEL (floating) ===== */
         #adminBar {
         display: none; /* shown only when isAdmin = true */
         position: fixed;
         top: 70px;
         right: 16px;
         background: rgba(43, 15, 29, 0.9);
         border-radius: 12px;
         padding: 6px 8px;
         font-size: 11px;
         box-shadow: 0 2px 10px rgba(0, 0, 0, 0.6);
         z-index: 9000;
         backdrop-filter: blur(6px);
         min-width: 240px;
         }
         #adminBar span {
         display: block;
         margin-bottom: 4px;
         color: #ffb6c1;
         text-align: left;
         }
         #adminBarButtons {
         display: flex;
         flex-wrap: wrap;
         gap: 6px;
         justify-content: flex-end;
         }
         #adminBarButtons button {
         padding: 6px 10px;
         border-radius: 10px;
         border: 1px solid #ff69b4;
         background: transparent;
         color: #ffb6c1;
         font-weight: 600;
         cursor: pointer;
         box-shadow: none;
         font-size: 11px;
         white-space: nowrap;
         transition: background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
         }
         #adminBarButtons button:hover {
         background: rgba(255,105,180,0.15);
         box-shadow: 0 0 10px rgba(255,105,180,0.2);
         }
         /* Mobile: pin it near bottom as a bar */
         @media (max-width: 600px) {
         #adminBar {
         top: auto;
         bottom: 80px;
         right: 10px;
         left: 10px;
         display: none;
         }
         #adminBar span {
         margin-bottom: 4px;
         text-align: center;
         }
         #adminBarButtons {
         justify-content: center;
         }
         }
         /* ===== GRID & CARDS ===== */
         .grid {
         display: grid;
         grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
         gap: 20px;
         justify-items: center;
         padding: 20px;
         }
         .card {
         background: #2b0f1d;
         border-radius: 12px;
         overflow: hidden;
         text-align: center;
         transition: transform 0.15s, box-shadow 0.25s ease;
         cursor: pointer;
         box-shadow: 0 2px 8px rgba(255,182,193,0.2);
         width: 100%;
         max-width: 150px;
         position: relative;
         }
         .card:hover {
         transform: scale(1.05);
         box-shadow: 0 0 15px rgba(255,182,193,0.6);
         }
         .card.read {
         background: #2b0f1d;
         box-shadow: 0 0 12px rgba(255,105,180,0.5), 0 0 6px rgba(255,182,193,0.3);
         border: 1px solid rgba(255,105,180,0.3);
         }
         /* Softer glow for unread cards */
         .card:not(.read) {
         box-shadow: 0 0 6px rgba(255,182,193,0.2);
         }
         .card:not(.read):hover {
         box-shadow: 0 0 12px rgba(255,182,193,0.35);
         }
         .card.read:hover {
         transform: scale(1.07);
         box-shadow: 0 0 20px rgba(255,105,180,0.7);
         }
         .card img {
         width: 100%;
         height: 220px;
         object-fit: cover;
         display: block;
         margin: 0 auto;
         background: #3b1a28;
         border-radius: 6px;
         }
         .card .title {
         font-weight: bold;
         margin: 6px 8px;
         font-size: 13px;
         min-height: 36px;
         color: #ffc0cb;
         }
         .card .meta {
         font-size: 11px;
         margin: 2px;
         color: #f8d1d8;
         padding-bottom: 8px;
         }
         .card .isbn {
         font-size: 10px;
         color: #eea4b7;
         margin-top: 4px;
         }
         /* ===== PAGE SECTIONS (LIBRARY vs WISHLIST) ===== */
         .page-section {
         transition: opacity 0.3s ease, transform 0.3s ease;
         }
         .page-section.hidden {
         opacity: 0;
         transform: translateX(-20px);
         pointer-events: none;
         position: absolute;
         left: 0;
         right: 0;
         }
         .page-section.active {
         opacity: 1;
         transform: translateX(0);
         position: relative;
         pointer-events: auto;
         }
         /* ===== POPUP ===== */
         @keyframes fadeIn {
         from {opacity: 0;}
         to {opacity: 1;}
         }
         @keyframes slideUp {
         from {transform: translateY(15px); opacity: 0;}
         to {transform: translateY(0); opacity: 1;}
         }
         #popupOverlay {
         position: fixed;
         top: 0; left: 0;
         width: 100%; height: 100%;
         background: rgba(30,13,20,0.95);
         backdrop-filter: blur(6px);
         display: none;
         justify-content: center;
         align-items: center;
         z-index: 9999;
         animation: fadeIn 0.25s ease;
         }
         #popupContent {
         background: #2b0f1d;
         padding: 20px;
         border-radius: 16px;
         max-width: 700px;
         width: 90%;
         color: #fff;
         position: relative;
         display: flex;
         gap: 20px;
         align-items: center;
         animation: slideUp 0.25s ease;
         box-shadow: 0 0 25px rgba(255,182,193,0.5);
         }
         #popupContent img {
         max-width: 200px;
         height: auto;
         border-radius: 8px;
         flex-shrink: 0;
         box-shadow: 0 0 12px rgba(255,182,193,0.6);
         }
         .popup-info {
         display: flex;
         flex-direction: column;
         justify-content: center;
         align-items: center;
         gap: 10px;
         flex: 1;
         padding-left: 10px;
         padding-right: 10px;
         text-align: center;
         }
         .popup-info .title {
         font-size: 20px;
         font-weight: bold;
         color: #ffb6c1;
         text-shadow: 0 0 6px rgba(255,182,193,0.7);
         }
         .popup-info .meta {
         font-size: 14px;
         color: #f8d1d8;
         line-height: 1.4;
         }
         .popup-info .isbn {
         font-size: 12px;
         color: #eea4b7;
         }
         #popupContent.read {
         border: 1px solid rgba(255,105,180,0.3);
         box-shadow: 0 0 25px rgba(255,105,180,0.5);
         }
         /* ===== ADMIN FORM (add/edit) ===== */
         #adminFormOverlay {
         position: fixed;
         inset: 0;
         background: rgba(30,13,20,0.92);
         backdrop-filter: blur(6px);
         display: none;
         justify-content: center;
         align-items: center;
         z-index: 10001;
         }
         #adminFormCard {
         background: #2b0f1d;
         border-radius: 16px;
         padding: 18px;
         max-width: 720px;
         width: 90%;
         display: flex;
         gap: 18px;
         box-shadow: 0 0 24px rgba(255,182,193,0.6);
         position: relative;
         animation: slideUp 0.25s ease;
         }
         /* ===== MULTI-CREATE FULLSCREEN EDITOR ===== */
         #multiEditorOverlay {
         position: fixed;
         inset: 0;
         background: rgba(30,13,20,0.96);
         backdrop-filter: blur(6px);
         display: none;
         justify-content: center;
         align-items: center;
         z-index: 10002;
         }
         #multiEditorCard {
         background: #2b0f1d;
         border-radius: 16px;
         padding: 18px;
         max-width: 720px;
         width: 90%;
         display: flex;
         gap: 18px;
         box-shadow: 0 0 24px rgba(255,182,193,0.6);
         position: relative;
         animation: slideUp 0.25s ease;
         }
         #multiEditorClose {
         position: absolute;
         top: 10px;
         right: 10px;
         background: rgba(255,255,255,0.08);
         border: 1px solid rgba(255,255,255,0.2);
         color: #fff;
         border-radius: 6px;
         width: 28px;
         height: 28px;
         cursor: pointer;
         font-size: 18px;
         }
         #multiEditorImageWrap {
         flex-shrink: 0;
         display: flex;
         align-items: center;
         justify-content: center;
         }
         #multiEditorCoverPreview {
         width: 150px;
         height: auto;
         border-radius: 10px;
         box-shadow: 0 0 14px rgba(255,182,193,0.7);
         background: #3b1a28;
         }
         #multiEditorFields {
         display: flex;
         flex-direction: column;
         gap: 8px;
         flex: 1;
         }
         #multiEditorFields label {
         display: flex;
         flex-direction: column;
         font-size: 12px;
         color: #f8d1d8;
         }
         #multiEditorFields input[type="text"],
         #multiEditorFields input[type="date"] {
         margin-top: 3px;
         padding: 6px 8px;
         border-radius: 6px;
         border: 1px solid #bb7f8f;
         background: #1e0d14;
         color: #fff;
         font-size: 12px;
         }
         #multiEditorNavRow {
         margin-top: 10px;
         display: flex;
         justify-content: space-between;
         gap: 8px;
         }
         #multiEditorNavRow button {
         padding: 6px 12px;
         border-radius: 999px;
         border: none;
         background: #ff69b4;
         color: #1e0d14;
         font-weight: 600;
         cursor: pointer;
         box-shadow: 0 0 8px rgba(255,105,180,0.6);
         font-size: 11px;
         }
         #multiEditorNavRow button:disabled {
         opacity: 0.4;
         cursor: default;
         box-shadow: none;
         }
         #multiEditorSaveRow {
         margin-top: 10px;
         display: flex;
         justify-content: flex-end;
         }
         #multiEditorSaveAll {
         padding: 7px 16px;
         border-radius: 999px;
         border: none;
         background: #ff69b4;
         color: #1e0d14;
         font-weight: 600;
         cursor: pointer;
         box-shadow: 0 0 10px rgba(255,105,180,0.6);
         }
         #multiEditorSaveAll:hover {
         background: #ffc0cb;
         }
         @media (max-width: 600px) {
         #multiEditorCard {
         flex-direction: column;
         align-items: center;
         }
         }
         #adminFormClose {
         position: absolute;
         top: 10px;
         right: 10px;
         background: rgba(255,255,255,0.08);
         border: 1px solid rgba(255,255,255,0.2);
         color: #fff;
         border-radius: 6px;
         width: 28px;
         height: 28px;
         cursor: pointer;
         font-size: 18px;
         }
         #adminFormImageWrap {
         flex-shrink: 0;
         display: flex;
         align-items: center;
         justify-content: center;
         }
         #adminCoverPreview {
         width: 150px;
         height: auto;
         border-radius: 10px;
         box-shadow: 0 0 14px rgba(255,182,193,0.7);
         background: #3b1a28;
         }
         #adminFormFields {
         display: flex;
         flex-direction: column;
         gap: 8px;
         flex: 1;
         }
         #adminFormTitle {
         margin: 0 0 6px;
         color: #ffb6c1;
         text-align: center;
         }
         #adminFormFields label {
         display: flex;
         flex-direction: column;
         font-size: 12px;
         color: #f8d1d8;
         }
         #adminFormFields input[type="text"] {
         margin-top: 3px;
         padding: 6px 8px;
         border-radius: 6px;
         border: 1px solid #bb7f8f;
         background: #1e0d14;
         color: #fff;
         font-size: 12px;
         }
         /* Shared input styling for dashboard and admin fields */
         input[type="text"],
         input[type="number"],
         input[type="date"],
         select,
         textarea {
         background: #2b0f1d;
         border: 1px solid #bb7f8f;
         color: #fff;
         border-radius: 6px;
         font-size: 12px;
         padding: 6px 8px;
         box-shadow: 0 0 6px rgba(255,182,193,0.2) inset;
         appearance: none;
         -webkit-appearance: none;
         transition: border-color 0.15s ease, box-shadow 0.2s ease;
         }
         input[type="text"]:focus,
         input[type="number"]:focus,
         input[type="date"]:focus,
         select:focus,
         textarea:focus {
         outline: 1px solid #ff69b4;
         box-shadow: 0 0 8px rgba(255,105,180,0.45);
         }
         /* Scrollbar styling */
         * {
         scrollbar-width: thin;
         scrollbar-color: #ff69b4 #1e0d14;
         }
         ::-webkit-scrollbar {
         width: 10px;
         height: 10px;
         }
         ::-webkit-scrollbar-track {
         background: #1e0d14;
         border-radius: 10px;
         }
         ::-webkit-scrollbar-thumb {
         background: linear-gradient(180deg, #ff69b4 0%, #c2185b 100%);
         border-radius: 10px;
         border: 1px solid #2b0f1d;
         box-shadow: 0 0 6px rgba(255,105,180,0.5);
         }
         ::-webkit-scrollbar-thumb:hover {
         background: linear-gradient(180deg, #ffc0cb 0%, #ff69b4 100%);
         }
         /* Custom date dropdown trio */
         .date-select-row {
         display: flex;
         gap: 6px;
         margin-top: 4px;
         }
         .date-select-row select {
         flex: 1 1 0;
         padding: 6px 8px;
         border-radius: 6px;
         border: 1px solid #bb7f8f;
         background: #1e0d14;
         color: #fff;
         font-size: 12px;
         }
         .date-select-row select:focus {
         outline: 1px solid #ff69b4;
         }
         /* ===== SUGGESTION ROWS (Title / Authors / Publisher) ===== */
         .suggestion-row {
         display: none;
         flex-wrap: wrap;
         gap: 6px;
         margin-top: 4px;
         }
         .suggestion-chip {
         border: none;
         border-radius: 999px;
         padding: 3px 10px;
         font-size: 11px;
         background: rgba(255,182,193,0.18);
         color: #ffb6c1;
         cursor: pointer;
         white-space: nowrap;
         }
         .suggestion-chip:hover {
         background: rgba(255,182,193,0.35);
         }
         #adminReadWrapper {
         margin-top: 6px;
         font-size: 12px;
         }
         #adminReadWrapper input {
         margin-right: 6px;
         }
         #adminFormButtons {
         display: flex;
         justify-content: flex-end;
         margin-top: 10px;
         }
         #adminFormSave {
         padding: 7px 16px;
         border-radius: 999px;
         border: none;
         background: #ff69b4;
         color: #1e0d14;
         font-weight: 600;
         cursor: pointer;
         box-shadow: 0 0 10px rgba(255,105,180,0.6);
         }
         #adminFormSave:hover {
         background: #ffc0cb;
         }
         @media (max-width: 600px) {
         #adminFormCard {
         flex-direction: column;
         align-items: center;
         }
         }
         #popupClose {
         position: absolute;
         top: 12px;
         right: 12px;
         background: rgba(255,255,255,0.08);
         border: 1px solid rgba(255,255,255,0.15);
         color: #fff;
         font-size: 20px;
         font-weight: bold;
         border-radius: 6px;
         width: 30px;
         height: 30px;
         cursor: pointer;
         transition: background 0.2s, transform 0.1s;
         }
         #popupClose:hover {
         background: rgba(255,182,193,0.3);
         transform: scale(1.1);
         }
         #popupBuy {
         margin-top: 6px;
         padding: 8px 16px;
         border-radius: 999px;
         border: none;
         background: #ff69b4;
         color: #1e0d14;
         font-weight: 700;
         cursor: pointer;
         box-shadow: 0 0 10px rgba(255,105,180,0.6);
         display: none;
         gap: 8px;
         align-items: center;
         justify-content: center;
         }
         #popupBuy .buy-icon {
         display: inline-flex;
         width: 20px;
         height: 20px;
         border-radius: 50%;
         align-items: center;
         justify-content: center;
         font-size: 12px;
         font-weight: 800;
         color: #1e0d14;
         }
        .buy-button {
            margin-top: 10px;
            padding: 10px 18px;
            border-radius: 999px;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: 700;
            font-size: 15px;
            transition: transform 0.2s ease, box-shadow 0.25s ease;
            box-shadow: 0 0 12px rgba(255,105,180,0.4);
        }
        .buy-logo {
            width: 22px;
            height: 22px;
        }

        /* Hover */
        .buy-button:hover {
            transform: scale(1.06);
            box-shadow: 0 0 18px rgba(255,182,193,0.6);
        }

        /* Amazon */
        .buy-amazon {
            background: linear-gradient(135deg,#ffb347,#ff9900);
            color: #1e0d14;
        }

        /* Crunchyroll */
        .buy-crunchyroll {
            background: linear-gradient(135deg,#ff914d,#f26b1d);
            color: #1e0d14;
        }
         #popupBuy.buy-generic {
         background: #2b0f1d;
         color: #ffb6c1;
         border: 1px solid #ffb6c1;
         box-shadow: none;
         }
         /* Admin controls inside popup */
         #popupAdminControls {
         margin-top: 8px;
         display: none;
         gap: 8px;
         flex-wrap: wrap;
         justify-content: center;
         }
         #popupAdminControls button {
         padding: 5px 10px;
         border-radius: 999px;
         border: none;
         cursor: pointer;
         font-size: 12px;
         background: #ff69b4;
         color: #1e0d14;
         font-weight: 600;
         }
         #popupAdminControls button.delete {
         background: #ff5555;
         color: #fff;
         }
         #popupAdminControls button:hover {
         opacity: 0.9;
         }
         /* ===== BACK TO TOP ===== */
         #backToTop {
         position: fixed;
         bottom: 24px;
         right: 24px;
         background: #2b0f1d;
         color: #ff69b4;
         border: 2px solid #ff69b4;
         border-radius: 50%;
         width: 48px;
         height: 48px;
         cursor: pointer;
         opacity: 0;
         visibility: hidden;
         box-shadow: 0 0 12px rgba(255,182,193,0.4);
         transition: opacity 0.3s, visibility 0.3s, transform 0.15s;
         z-index: 10000;
         display: flex;
         align-items: center;
         justify-content: center;
         }
         #backToTop::before {
         content: '';
         display: inline-block;
         border-left: 8px solid transparent;
         border-right: 8px solid transparent;
         border-bottom: 12px solid #ff69b4;
         }
         #backToTop.show {
         opacity: 1;
         visibility: visible;
         }
         #backToTop:hover {
         transform: scale(1.1);
         box-shadow: 0 0 20px rgba(255,182,193,0.6);
         }
         /* Highlight for multi-selected cards (brighter than read glow) */
         .card.multi-selected {
         background: #3b1a2f;
         border: 2px solid #fff59d;
         box-shadow:
         0 0 24px rgba(255, 255, 180, 0.95),
         0 0 10px rgba(255, 255, 255, 0.7);
         }
         /* Bottom multi-select action bar */
         #multiSelectBar {
         position: fixed;
         left: 0;
         right: 0;
         bottom: 0;
         padding: 8px 14px;
         background: rgba(30,13,20,0.96);
         border-top: 1px solid rgba(255,182,193,0.35);
         display: none;
         align-items: center;
         justify-content: space-between;
         gap: 10px;
         z-index: 10040;
         backdrop-filter: blur(6px);
         }
         #multiSelectInfo {
         font-size: 12px;
         color: #f8d1d8;
         }
         #multiSelectActions {
         display: flex;
         flex-wrap: wrap;
         gap: 6px;
         }
         .multi-select-btn {
         padding: 5px 10px;
         border-radius: 999px;
         border: none;
         font-size: 12px;
         font-weight: 600;
         cursor: pointer;
         box-shadow: 0 0 8px rgba(255,105,180,0.5);
         }
         .multi-select-btn.primary {
         background: #ff69b4;
         color: #1e0d14;
         }
         .multi-select-btn.danger {
         background: #ff5555;
         color: #fff;
         }
         .multi-select-btn.secondary {
         background: #2b0f1d;
         color: #ffb6c1;
         border: 1px solid #ffb6c1;
         box-shadow: none;
         }
         @media (max-width: 600px) {
         #multiSelectBar {
         flex-direction: column;
         align-items: flex-start;
         }
         .dash-library {
         grid-template-columns: 1fr;
         }
         .dash-library-list,
         .dash-library-details {
         min-height: 0;
         }
         }
         #multiCreatePanel {
         position: relative;
         padding-bottom: 70px; /* makes space for + button */
         }
         /* Styled date picker */
         #adminDateInput {
         background: #1e0d14;
         border: 1px solid #bb7f8f;
         color: #fff;
         padding: 6px 8px;
         border-radius: 6px;
         font-size: 12px;
         box-shadow: 0 0 6px rgba(255,182,193,0.3) inset;
         }
         /* Remove chrome default icon */
         #adminDateInput::-webkit-calendar-picker-indicator {
         filter: invert(85%) sepia(20%) saturate(300%) hue-rotate(290deg);
         cursor: pointer;
         }
         /* Firefox fix */
         input[type="date"] {
         color-scheme: dark;
         }
         /* Prevent selecting Total Books text */
         #totalBooksTop,
         #totalBooksBottom {
         user-select: none;
         }
         /* ===== AUTH MODAL (SIGN IN / SIGN UP) ===== */
         #authModalOverlay {
         position: fixed;
         inset: 0;
         background: rgba(30,13,20,0.92);
         backdrop-filter: blur(6px);
         display: none;
         justify-content: center;
         align-items: center;
         z-index: 10050;
         animation: fadeIn 0.25s ease;
         }
         #authModalCard {
         background: #2b0f1d;
         border-radius: 16px;
         padding: 20px 20px 18px;
         width: 90%;
         max-width: 420px;
         box-shadow: 0 0 24px rgba(255,182,193,0.7);
         position: relative;
         animation: slideUp 0.25s ease;
         color: #fff;
         }
         #authModalClose {
         position: absolute;
         top: 10px;
         right: 10px;
         background: rgba(255,255,255,0.08);
         border: 1px solid rgba(255,255,255,0.2);
         color: #fff;
         border-radius: 6px;
         width: 28px;
         height: 28px;
         cursor: pointer;
         font-size: 18px;
         }
         #authModalTitle {
         margin: 0 0 10px;
         text-align: center;
         color: #ffb6c1;
         text-shadow: 0 0 6px rgba(255,182,193,0.7);
         }
         /* Tabs */
         #authTabs {
         display: flex;
         gap: 8px;
         margin-bottom: 10px;
         border-radius: 999px;
         background: rgba(255,182,193,0.08);
         padding: 3px;
         }
         .auth-tab {
         flex: 1;
         border-radius: 999px;
         border: none;
         padding: 6px 0;
         background: transparent;
         color: #f8d1d8;
         font-size: 13px;
         cursor: pointer;
         }
         .auth-tab.active {
         background: #ff69b4;
         color: #1e0d14;
         font-weight: 600;
         box-shadow: 0 0 8px rgba(255,105,180,0.6);
         }
         /* Error message */
         .auth-error {
         background: rgba(255,85,85,0.16);
         border: 1px solid rgba(255,85,85,0.5);
         border-radius: 8px;
         padding: 6px 8px;
         font-size: 12px;
         color: #ffaaaa;
         margin-bottom: 8px;
         }
         /* Forms */
         .auth-form {
         display: none;
         flex-direction: column;
         gap: 8px;
         }
         .auth-form.active {
         display: flex;
         }
         .auth-form label {
         font-size: 12px;
         color: #f8d1d8;
         display: flex;
         flex-direction: column;
         }
         .auth-form input[type="email"],
         .auth-form input[type="password"] {
         margin-top: 3px;
         padding: 7px 8px;
         border-radius: 6px;
         border: 1px solid #bb7f8f;
         background: #1e0d14;
         color: #fff;
         font-size: 13px;
         }
         .auth-submit {
         margin-top: 6px;
         padding: 7px 16px;
         border-radius: 999px;
         border: none;
         background: #ff69b4;
         color: #1e0d14;
         font-weight: 600;
         cursor: pointer;
         box-shadow: 0 0 10px rgba(255,105,180,0.6);
         font-size: 13px;
         }
         .auth-submit:hover {
         background: #ffc0cb;
         }
         .auth-link {
         margin-top: 4px;
         border: none;
         background: none;
         color: #f8d1d8;
         font-size: 12px;
         text-align: left;
         cursor: pointer;
         text-decoration: underline;
         }
         /* Divider + Google button */
         .auth-divider {
         display: flex;
         align-items: center;
         gap: 6px;
         margin: 10px 0 6px;
         font-size: 11px;
         color: #f8d1d8;
         }
         .auth-divider span:first-child,
         .auth-divider span:last-child {
         flex: 1;
         height: 1px;
         background: rgba(255,182,193,0.25);
         }
         .auth-google {
         padding: 7px 16px;
         border-radius: 999px;
         border: 1px solid #fff;
         background: #fff;
         color: #1e0d14;
         font-weight: 600;
         font-size: 13px;
         cursor: pointer;
         display: flex;
         align-items: center;
         justify-content: center;
         gap: 6px;
         }
         .auth-google:hover {
         filter: brightness(1.05);
         }
         .auth-note {
         margin-top: 6px;
         font-size: 11px;
         color: #f8d1d8;
         opacity: 0.8;
         }
         @media (max-width: 600px) {
         #authModalCard {
         max-width: 360px;
         padding: 18px 16px 14px;
         }
         }
         /* ===== MOBILE ===== */
         @media (max-width: 600px) {
         body {
         padding-bottom: 72px; /* leave space for sticky bars/buttons */
         }
         .container {
         padding: 12px;
         }
         h1 {
         font-size: 22px;
         margin-top: 14px;
         }
         #searchInput, #wishlistSearchInput {
         width: 100%;
         margin: 10px auto;
         font-size: 13px;
         }
         .grid {
         grid-template-columns: repeat(3, 1fr);
         gap: 14px;
         padding: 10px;
         }
         .card {
         max-width: 100%;
         }
         .counter {
         gap: 10px;
         font-size: 12px;
         }
         #multiSelectBar {
         padding: 10px;
         gap: 8px;
         }
         #multiSelectActions {
         justify-content: flex-start;
         }
         .multi-select-btn {
         font-size: 11px;
         padding: 5px 9px;
         }
         #popupContent {
         flex-direction: column;
         align-items: center;
         gap: 15px;
         text-align: center;
         width: 94%;
         }
         #popupContent img {
         max-width: 150px;
         }
         .popup-info {
         padding-left: 0;
         padding-right: 0;
         font-size: 13px;
         }
         #adminFormCard,
         #multiEditorCard {
         max-width: 92%;
         width: 92%;
         flex-direction: column;
         }
         #adminFormImageWrap,
         #multiEditorImageWrap {
         justify-content: center;
         }
         #adminCoverPreview,
         #multiEditorCoverPreview {
         width: 130px;
         }
         #adminBar {
         right: 12px;
         left: 12px;
         bottom: 76px;
         top: auto;
         padding: 10px;
         }
         #adminBarButtons {
         gap: 8px;
         }
         #adminBarButtons button {
         flex: 1 1 45%;
         min-width: 120px;
         padding: 8px 12px;
         font-size: 12px;
         }
         #adminFormCard {
         padding: 14px;
         }
         #adminFormFields input[type="text"],
         #adminFormFields input[type="date"],
         #adminAmazonInput {
         width: 100%;
         font-size: 13px;
         padding: 8px 10px;
         }
         #adminFormButtons {
         justify-content: stretch;
         }
         #adminFormSave {
         width: 100%;
         font-size: 13px;
         padding: 10px 14px;
         }
         #multiEditorCard {
         padding: 14px;
         }
         #multiEditorNavRow button,
         #multiEditorSaveAll,
         #multiEditorAddVolume {
         width: 100%;
         font-size: 13px;
         padding: 10px 12px;
         }
         #multiEditorNavRow {
         flex-direction: column;
         }
         #backToTop {
         right: 16px;
         bottom: 16px;
         width: 44px;
         height: 44px;
         }
         }
      </style>
   </head>
   <body>
      <button id="menuToggle" class="menu-toggle" aria-label="Menu">
      <span></span>
      <span></span>
      <span></span>
      </button>
      <div id="menuPanel" class="menu-panel">
         <div class="menu-items">
            <button class="menu-item" data-target="library">Library</button>
            <button class="menu-item" data-target="wishlist">Wishlist</button>
         </div>
         <div id="authSection" class="auth-section" style="display:none;">
            <button class="menu-item" id="menuDashboard" data-target="dashboard" style="display:none;">Dashboard</button>
            <div id="authStatus" class="auth-section-status">Not signed in</div>
            <button id="loginBtn" class="auth-btn">Sign in</button>
            <button id="logoutBtn" class="auth-btn secondary" style="display:none;">Sign out</button>
         </div>
      </div>
      <!-- Auth Sign In / Sign Up Modal -->
      <div id="authModalOverlay">
         <div id="authModalCard">
            <button id="authModalClose" title="Close">&times;</button>
            <h2 id="authModalTitle">Admin Sign In</h2>
            <div id="authTabs">
               <button id="authTabSignIn" class="auth-tab active">Sign In</button>
               <button id="authTabSignUp"  class="auth-tab">Sign Up</button>
            </div>
            <div id="authError" class="auth-error" style="display:none;"></div>
            <!-- SIGN IN FORM -->
            <form id="authSignInForm" class="auth-form active">
               <label>
               Email
               <input type="email" id="signInEmail" autocomplete="email" required>
               </label>
               <label>
               Password
               <input type="password" id="signInPassword" autocomplete="current-password" required>
               </label>
               <button type="submit" class="auth-submit">Sign In</button>
               <button type="button" id="authForgotPassword" class="auth-link">
               Forgot password?
               </button>
               <div class="auth-divider">
                  <span></span><span>or</span><span></span>
               </div>
               <button type="button" id="authGoogleSignIn" class="auth-google">
               <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg"
                  alt="G"
                  style="width:18px; height:18px; display:inline-block;">
               Sign in with Google
               </button>
            </form>
            <!-- SIGN UP FORM -->
            <form id="authSignUpForm" class="auth-form">
               <label>
               Email
               <input type="email" id="signUpEmail" autocomplete="email" required>
               </label>
               <label>
               Password
               <input type="password" id="signUpPassword" autocomplete="new-password" required>
               </label>
               <label>
               Confirm Password
               <input type="password" id="signUpPasswordConfirm" autocomplete="new-password" required>
               </label>
               <button type="submit" class="auth-submit">Create Account</button>
               <p class="auth-note">
                  New accounts are not admins by default. An admin must grant you admin permissions in Firebase.
               </p>
            </form>
         </div>
      </div>
         <div class="container">
            <h1 id="pageTitle">Tyler's Manga Library</h1>
            <!-- Admin bar (only shown for admin when signed in) -->
            <div id="adminBar">
               <span>Admin tools</span>
               <div id="adminBarButtons">
                  <button id="adminSettingsBtn" class="settings-icon-btn" title="Settings"></button>
                  <button id="adminAddLibrary">Add Library Book</button>
               <button id="adminAddWishlist">Add Wishlist Item</button>
               <button id="adminMultiSelect">Multi-Select</button>
            </div>
         </div>
         <!-- LIBRARY SECTION -->
         <div id="librarySection" class="page-section active">
            <div class="counter" id="bookCountTop">
               <span class="total" id="totalBooksTop"></span>
               <span class="read" id="readBooksTop"></span>
            </div>
            <input type="text" id="searchInput" placeholder="Search by title, author, publisher, ISBN...">
            <div class="grid" id="bookGrid"></div>
            <div class="counter" id="bookCountBottom">
               <span class="total" id="totalBooksBottom"></span>
               <span class="read" id="readBooksBottom"></span>
            </div>
         </div>
         <!-- WISHLIST SECTION -->
         <div id="wishlistSection" class="page-section hidden">
            <div id="wishlistHeader">
               <div class="counter" style="margin:0;">
                  <span class="total" id="wishlistCount"></span>
               </div>
               <div id="wishlistCountdown">
                  <div class="countdown-label">Next Release</div>
                  <div id="wishlistCountdownTitle"></div>
                  <div id="wishlistCountdownTimer"></div>
               </div>
            </div>
            <input
               type="text"
               id="wishlistSearchInput"
               placeholder="Search wishlist by title, author, publisher, ISBN...">
            <div class="grid" id="wishlistGrid"></div>
         </div>
         <!-- DASHBOARD SECTION (admins only) -->
         <div id="dashboardSection" class="page-section hidden">
            <div class="dashboard-grid">
               <div class="stat-stack">
                  <div class="stat-card mini">
                     <h3>Total Library Books</h3>
                     <div class="stat-value" id="statTotalLibrary">0</div>
                  </div>
                  <div class="stat-card mini">
                     <h3>Wishlist Items</h3>
                     <div class="stat-value" id="statWishlist">0</div>
                  </div>
               </div>
               <div class="stat-card">
                  <h3>Read / Unread</h3>
                  <div class="pie" id="pieRead" style="--pct:0;">
                     <div class="pie-label" id="statReadPct">0%</div>
                  </div>
                  <div class="stat-value"><span id="statRead">0</span> / <span id="statUnread">0</span></div>
               </div>
               <div class="stat-card">
                  <h3>Library vs Wishlist</h3>
                  <div class="pie" id="pieCollection" style="--pct:0;">
                     <div class="pie-label" id="statCollectionPct">0%</div>
                  </div>
                  <div class="stat-value"><span id="statLibShare">0</span> / <span id="statWishShare">0</span></div>
               </div>
               <div class="stat-card">
                  <h3>Top 3 Demographics</h3>
                  <div class="stat-list" id="statTopDemographics"></div>
               </div>
               <div class="stat-card">
                  <h3>Top 3 Publishers</h3>
                  <div class="stat-list" id="statTopPublishers"></div>
               </div>
               <div class="stat-card">
                  <h3>Top 3 Genres</h3>
                  <div class="stat-list" id="statTopGenres"></div>
               </div>
            <div class="stat-card" id="statNextCard" style="cursor:pointer;">
               <h3>Next Wishlist Release</h3>
               <div class="stat-value next-release" id="statNextRelease">None scheduled</div>
               <div class="stat-sub" id="statNextReleaseDate"></div>
               <div class="stat-sub" id="statNextCountdown"></div>
            </div>
            <div class="stat-card">
               <h3>Collection MSRP</h3>
               <div class="stat-value" id="statCollectionValue">$0.00</div>
            </div>
               <div class="stat-card">
                  <h3 id="statCurrentYearTitle">Current Reads</h3>
                  <div class="stat-value" id="statCurrentYearValue">0</div>
                  <div class="stat-sub" id="statCurrentYearSub">Year-to-date</div>
               </div>
               <div class="stat-card">
                  <h3>Avg Days From Purchase to Read</h3>
                  <div class="stat-value" id="statAvgReadTime">--</div>
                  <div class="stat-sub" id="statAvgReadTimeSub">When both dates exist</div>
               </div>
               <div class="stat-duo">
                  <div class="stat-card tall">
                     <h3>Reads Per Month <span id="statMonthlyYear"></span></h3>
                     <div class="line-chart" id="statMonthlyLine"></div>
                  </div>
                  <div class="stat-card tall">
                     <h3>Reads by Day of Week (lifetime)</h3>
                     <div class="bar-chart" id="statDayOfWeekBars"></div>
                  </div>
               </div>
               <div class="stat-card wide">
                  <h3>Activity Log</h3>
                  <div class="activity-log" id="activityLogList"></div>
               </div>
               <div class="stat-card wide">
                  <h3>Library Manager</h3>
                     <div class="dash-library">
                     <div class="dash-library-list" id="dashLibraryList"></div>
                     <div class="dash-library-details">
                     <div id="dashLibraryEmpty">Select a series or book to edit</div>
                     <div id="dashSeriesForm" style="display:none;">
                        <div class="dash-detail-title" id="dashSeriesTitle"></div>
                        <div class="dash-detail-row">
                           <label><input type="checkbox" id="dashSeriesRead"> Mark series as read</label>
                        </div>
                        <div class="dash-detail-row">
                           <span>Publisher</span>
                           <input type="text" id="dashSeriesPublisher" placeholder="Set publisher for series">
                        </div>
                        <div class="dash-detail-row">
                           <span>Demographic</span>
                           <select id="dashSeriesDemographic">
                              <option value="">Select demographic</option>
                              <option value="Shounen">Shounen</option>
                              <option value="Seinen">Seinen</option>
                              <option value="Shoujo">Shoujo</option>
                              <option value="Josei">Josei</option>
                           </select>
                        </div>
                        <div class="dash-detail-row">
                           <span>Genre</span>
                           <input type="text" id="dashSeriesGenre" placeholder="Primary genre">
                        </div>
                        <div class="dash-detail-row">
                           <span>Sub-Genre</span>
                           <input type="text" id="dashSeriesSubGenre" placeholder="Secondary genre / theme">
                        </div>
                        <div class="dash-detail-row">
                           <span>Date Purchased</span>
                           <input type="date" id="dashSeriesDatePurchased">
                        </div>
                        <div class="dash-detail-row">
                           <span>MSRP (per book)</span>
                           <input type="number" id="dashSeriesMSRP" step="0.01" min="0" placeholder="0.00">
                        </div>
                        <div class="dash-detail-actions">
                           <button class="dash-btn secondary" id="dashSeriesCancel">Cancel</button>
                           <button class="dash-btn primary" id="dashSeriesSave">Save Series</button>
                        </div>
                     </div>
                     <div id="dashLibraryForm" style="display:none;">
                        <div class="dash-detail-title" id="dashDetailTitle"></div>
                        <div class="dash-detail-row">
                           <label><input type="checkbox" id="dashDetailRead"> Mark as read</label>
                        </div>
                        <div class="dash-detail-row">
                           <span>Date Purchased</span>
                           <input type="date" id="dashDetailDatePurchased">
                        </div>
                        <div class="dash-detail-row" id="dashDetailDateReadRow">
                           <span>Date Read</span>
                           <input type="date" id="dashDetailDateRead">
                        </div>
                        <div class="dash-detail-row">
                           <span>MSRP (per book)</span>
                           <input type="number" id="dashDetailMSRP" step="0.01" min="0" placeholder="0.00">
                        </div>
                        <div class="dash-detail-actions">
                           <button class="dash-btn secondary" id="dashDetailCancel">Cancel</button>
                           <button class="dash-btn primary" id="dashDetailSave">Save Changes</button>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </div>
      </div>
      <!-- Admin Add/Edit Form Overlay -->
      <div id="adminFormOverlay" style="display:none;">
         <div id="adminFormCard">
            <button id="adminFormClose" title="Close">&times;</button>
            <div id="adminFormImageWrap">
               <img id="adminCoverPreview" src="https://via.placeholder.com/150x220?text=No+Cover" alt="Cover">
            </div>
            <div id="adminFormFields">
               <h2 id="adminFormTitle">Add Book</h2>
               <label>
               Title
               <input type="text" id="adminTitleInput" autocomplete="off">
               </label>
               <div style="display:flex; align-items:center; justify-content:space-between; margin-top:4px;">
                  <div id="adminTitleSuggestions" class="suggestion-row"></div>
                  <button
                     type="button"
                     id="adminMultiCreateBtn"
                     style="display:none; margin-left:8px; padding:4px 10px; border-radius:999px; border:none; background:#ff69b4; color:#1e0d14; font-size:11px; font-weight:600; cursor:pointer; box-shadow:0 0 8px rgba(255,105,180,0.6); white-space:nowrap;">
                  Multi-Create Volumes
                  </button>
               </div>
               <!-- This must remain INSIDE adminFormFields -->
               <div id="multiCreatePanel" style="display:none; margin-top:10px;">
                  <button id="multiCreateAddButton"
                     style="
                     position: absolute;
                     bottom: 18px;
                     right: 18px;
                     width: 46px;
                     height: 46px;
                     background:#ff69b4;
                     border:none;
                     border-radius:50%;
                     color:#1e0d14;
                     font-size:26px;
                     font-weight:900;
                     cursor:pointer;
                     box-shadow:0 0 16px rgba(255,105,180,0.7);
                     display:none;
                     z-index:20;
                     ">
                  +
                  </button>
                  <h3 style="color:#ffb6c1; text-align:center;">Multi-Create Volumes</h3>
                  <div id="multiCreateList"
                     style="display:flex; flex-direction:column; gap:8px; padding:10px;
                     background:#1e0d14; border-radius:12px;">
                  </div>
                  <button id="multiCreateSave"
                     style="margin-top:10px; padding:6px 12px; border-radius:999px;
                     background:#ff69b4; color:#1e0d14; border:none;
                     font-weight:600; cursor:pointer; box-shadow:0 0 10px rgba(255,105,180,0.6);">
                  Save All Volumes
                  </button>
               </div>
               <!-- EVERYTHING BELOW WAS OUTSIDE  now inside -->
               <label>
               Authors
               <input type="text" id="adminAuthorsInput" autocomplete="off">
               </label>
               <div id="adminAuthorSuggestions" class="suggestion-row"></div>
               <label>
               Publisher
               <input type="text" id="adminPublisherInput" autocomplete="off">
               </label>
               <div id="adminPublisherSuggestions" class="suggestion-row"></div>
               <label>
               Date
               <input type="date" id="adminDateInput" autocomplete="off">
               </label>
               <label>
               ISBN
               <input type="text" id="adminIsbnInput" autocomplete="off">
               </label>
               <label>
               Cover URL
               <input type="text" id="adminCoverInput" autocomplete="off" placeholder="Paste image URL here">
               </label>
               <label id="adminAmazonWrapper" style="display:none;">
               Amazon URL (wishlist only)
               <input type="text" id="adminAmazonInput" autocomplete="off" placeholder="https://www.amazon.com/...">
               </label>
               <label id="adminReadWrapper" style="display:none;">
               <input type="checkbox" id="adminReadInput">
               Mark as read (library only)
               </label>
               <label id="adminDateReadWrapper" style="display:none;">
               Date when read (library only)
               <input type="date" id="adminDateReadInput" autocomplete="off">
               </label>
               <div id="adminFormButtons">
                  <button id="adminFormSave">Save</button>
               </div>
            </div>
         </div>
      </div>
      <!-- Multi-Create Volumes Editor Overlay -->
      <div id="multiEditorOverlay" style="display:none;">
         <div id="multiEditorCard">
            <button id="multiEditorClose" title="Close">&times;</button>
            <div id="multiEditorImageWrap">
               <img id="multiEditorCoverPreview"
                  src="https://via.placeholder.com/150x220?text=No+Cover"
                  alt="Cover">
            </div>
            <div id="multiEditorFields">
               <h2 id="multiEditorTitle">Multi-Create Volumes</h2>
               <div id="multiEditorSeriesLabel"
                  style="margin-bottom:2px; font-size:13px; color:#ffb6c1;"></div>
               <div id="multiEditorVolumeLabel"
                  style="font-size:13px; color:#f8d1d8;"></div>
               <div id="multiEditorPosition"
                  style="font-size:11px; color:#eea4b7; margin-bottom:6px;"></div>
               <label>
               Title
               <input type="text" id="multiEditorTitleInput" autocomplete="off">
               </label>
               <label>
               Authors
               <input type="text" id="multiEditorAuthorsInput" autocomplete="off">
               </label>
               <label>
               Publisher
               <input type="text" id="multiEditorPublisherInput" autocomplete="off">
               </label>
               <label>
               Date
               <input type="date" id="multiEditorDateInput" autocomplete="off">
               </label>
               <label>
               ISBN
               <input type="text" id="multiEditorIsbnInput" autocomplete="off">
               </label>
               <label>
               Cover URL
               <input type="text" id="multiEditorCoverInput" autocomplete="off"
                  placeholder="Paste image URL here">
               </label>
               <label id="multiEditorAmazonWrapper" style="display:none;">
               Amazon URL (wishlist only)
               <input type="text" id="multiEditorAmazonInput" autocomplete="off"
                  placeholder="https://www.amazon.com/...">
               </label>
               <label id="multiEditorReadWrapper" style="display:none;">
               <input type="checkbox" id="multiEditorReadInput">
               Mark as read (library only)
               </label>
               <label id="multiEditorDateReadWrapper" style="display:none;">
               Date when read (library only)
               <input type="date" id="multiEditorDateReadInput" autocomplete="off">
               </label>
               <button id="multiEditorAddVolume"
                  type="button"
                  style="margin-top:10px; padding:6px 12px; border-radius:999px;
                  border:none; background:#ff69b4; color:#1e0d14;
                  font-weight:600; cursor:pointer; box-shadow:0 0 8px rgba(255,105,180,0.6);">
               + Add Volume
               </button>
               <div id="multiEditorNavRow">
                  <button id="multiEditorPrev" type="button"> Prev</button>
                  <button id="multiEditorNext" type="button">Next </button>
               </div>
               <div id="multiEditorSaveRow">
                  <button id="multiEditorSaveAll" type="button">
                  Save All Volumes
                  </button>
               </div>
            </div>
         </div>
      </div>
      <!-- Popup overlay -->
      <div id="popupOverlay">
         <div id="popupContent">
            <button id="popupClose" title="Close">&times;</button>
            <img id="popupImage" src="" alt="Cover">
            <div class="popup-info">
               <div class="title" id="popupTitle"></div>
               <div class="meta" id="popupMeta"></div>
               <div class="isbn" id="popupISBN"></div>
               <button id="popupBuy" class="" style="display:none;">
                   <img id="popupBuyLogo" class="buy-logo" alt="">
                   <span id="popupBuyText"></span>
               </button>
               <div id="popupAdminControls">
                  <button id="popupToggleRead">Toggle Read</button>
                  <button id="popupEdit">Edit</button>
                  <button id="popupDelete" class="delete">Delete</button>
               </div>
            </div>
         </div>
      </div>
      <button id="backToTop" title="Back to Top"></button>
      <!-- Settings overlay -->
      <div id="settingsOverlay">
         <div id="settingsCard">
            <button id="settingsClose" title="Close">&times;</button>
            <h3 class="settings-title">Dashboard Settings</h3>
            <div class="settings-actions">
               <button id="exportJsonBtn" class="settings-btn">Export to JSON</button>
               <button id="exportCsvBtn" class="settings-btn">Export to CSV</button>
               <button id="exportCoversBtn" class="settings-btn">Export Covers as Zip</button>
            </div>
         </div>
      </div>
      <!-- Multi-Select Action Bar -->
      <div id="multiSelectBar">
         <div id="multiSelectInfo">0 selected</div>
         <div id="multiSelectActions">
            <button id="multiSelectMove" class="multi-select-btn primary">Move to Wishlist</button>
            <button id="multiSelectEdit" class="multi-select-btn secondary">Edit Selected</button>
            <button id="multiSelectMarkRead" class="multi-select-btn secondary">Mark Read</button>
            <button id="multiSelectMarkUnread" class="multi-select-btn secondary">Mark Unread</button>
            <button id="multiSelectDelete" class="multi-select-btn danger">Delete</button>
            <button id="multiSelectCancel" class="multi-select-btn secondary">Cancel</button>
         </div>
      </div>
      <!-- Firebase + App Logic -->
      <script type="module">
         // ===== FIREBASE CONFIG (your live config) =====
         const firebaseConfig = {
           apiKey: "AIzaSyCOOnlmEcAcJywsS93LLfLSywy9ENqnppM",
           authDomain: "tyler-manga-library.firebaseapp.com",
           projectId: "tyler-manga-library",
           storageBucket: "tyler-manga-library.firebasestorage.app",
           messagingSenderId: "307412068362",
           appId: "1:307412068362:web:6cfe5666187439dfa757f3"
         };
         
         import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
         import {
           getAuth,
           GoogleAuthProvider,
           signInWithPopup,
           signOut,
           onAuthStateChanged,
           createUserWithEmailAndPassword,
           signInWithEmailAndPassword,
           sendPasswordResetEmail
         } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
         import {
           getFirestore,
           collection,
           getDocs,
           addDoc,
           updateDoc,
           deleteDoc,
           doc,
           getDoc,
           setDoc
         } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";
         
         // ===== INIT =====
         const app   = initializeApp(firebaseConfig);
         const auth  = getAuth(app);
         const db    = getFirestore(app);
         const provider = new GoogleAuthProvider();
         
         // ===== GLOBAL STATE =====
         const ADMIN_EMAIL = "imokissick@gmail.com";
         
         let isAdmin = false;
         let libraryBooks = [];
         let wishlistItems = [];
         let readClickState = 0; // 0 = default, 1 = only read, 2 = only unread
         let secretClickCount = 0;
         let secretTimer = null;
         let currentPopupBook = null;
         let currentSeriesSuggestion = null; // { baseName, suggestionVolumes, author, publisher }
         let currentSectionKey = 'library';  // 'library' or 'wishlist'
         let dashSelectedBookId = null;
         let dashSelectedSeriesKey = null;
         let dashGroupedSeries = [];
         let dashSeriesExpanded = new Set();
         let activityLog = [];
         
         // Multi-select state
         let multiSelectActive = false;
         let multiSelectedIds = new Set();
         let multiEditorMode = 'series'; // 'series' for multi-volume, 'selection' for multi-select edits
         
         
         // Multi-create editor state
         let multiCreateActive = false;
         let multiCreateVolumes = [];  // e.g. [55, 67, 89, 111]
         let multiCreateIndex  = 0;    // current index in that array
         let multiCreateItems  = [];   // detailed data for each volume
         // Wishlist countdown state
         let wishlistCountdownInterval = null;
         let nextWishlistRelease = null;
         // Calendar state
         let calendarMonthCursor = new Date();
         
         // DOM refs
         const menuToggle      = document.getElementById('menuToggle');
         const menuPanel       = document.getElementById('menuPanel');
         const pageTitle       = document.getElementById('pageTitle');
         const librarySection  = document.getElementById('librarySection');
         const wishlistSection = document.getElementById('wishlistSection');
         
         const totalTop        = document.getElementById('totalBooksTop');
         const totalBottom     = document.getElementById('totalBooksBottom');
         const readTop         = document.getElementById('readBooksTop');
         const readBottom      = document.getElementById('readBooksBottom');
         const wishlistCount   = document.getElementById('wishlistCount');
         const wishlistCountdownEl   = document.getElementById('wishlistCountdown');
         const wishlistCountdownTitle= document.getElementById('wishlistCountdownTitle');
         const wishlistCountdownTimer= document.getElementById('wishlistCountdownTimer');
         const wishlistCountdownDate = document.getElementById('wishlistCountdownDate');
         
         const bookGrid        = document.getElementById('bookGrid');
         const wishlistGrid    = document.getElementById('wishlistGrid');
         const dashboardSection= document.getElementById('dashboardSection');
         
         const searchInput     = document.getElementById('searchInput');
         const wishlistSearchInput = document.getElementById('wishlistSearchInput');
         const statTotalLibrary = document.getElementById('statTotalLibrary');
         const statRead         = document.getElementById('statRead');
         const statUnread       = document.getElementById('statUnread');
         const statWishlist     = document.getElementById('statWishlist');
         const statNextRelease  = document.getElementById('statNextRelease');
         const statNextReleaseDate = document.getElementById('statNextReleaseDate');
         const statNextCountdown= document.getElementById('statNextCountdown');
         const statCollectionValue = document.getElementById('statCollectionValue');
         const statCurrentYearTitle = document.getElementById('statCurrentYearTitle');
         const statCurrentYearValue = document.getElementById('statCurrentYearValue');
         const statCurrentYearSub   = document.getElementById('statCurrentYearSub');
         const statAvgReadTime      = document.getElementById('statAvgReadTime');
         const statAvgReadTimeSub   = document.getElementById('statAvgReadTimeSub');
         const statTopDemographics  = document.getElementById('statTopDemographics');
         const statTopPublishers    = document.getElementById('statTopPublishers');
         const statTopGenres        = document.getElementById('statTopGenres');
         const statMonthlyLine      = document.getElementById('statMonthlyLine');
         const statMonthlyYear      = document.getElementById('statMonthlyYear');
         const statDayOfWeekBars    = document.getElementById('statDayOfWeekBars');
         const releaseCalendar      = document.getElementById('releaseCalendar');
         const releaseCalendarEmpty = document.getElementById('releaseCalendarEmpty');
         const releaseCalendarLabel = document.getElementById('releaseCalendarLabel');
         const calendarPrevBtn      = document.getElementById('calendarPrev');
         const calendarNextBtn      = document.getElementById('calendarNext');
         const pieRead          = document.getElementById('pieRead');
         const pieCollection    = document.getElementById('pieCollection');
         const statReadPct      = document.getElementById('statReadPct');
         const statCollectionPct= document.getElementById('statCollectionPct');
         const statLibShare     = document.getElementById('statLibShare');
         const statWishShare    = document.getElementById('statWishShare');
         const dashLibraryList  = document.getElementById('dashLibraryList');
         const dashLibraryEmpty = document.getElementById('dashLibraryEmpty');
         const dashSeriesForm   = document.getElementById('dashSeriesForm');
         const dashSeriesTitle  = document.getElementById('dashSeriesTitle');
         const dashSeriesRead   = document.getElementById('dashSeriesRead');
         const dashSeriesDatePurchased = document.getElementById('dashSeriesDatePurchased');
         const dashSeriesDatePurchasedRow = dashSeriesDatePurchased ? dashSeriesDatePurchased.parentElement : null;
         const dashSeriesMSRP   = document.getElementById('dashSeriesMSRP');
         const dashSeriesPublisher = document.getElementById('dashSeriesPublisher');
         const dashSeriesDemographic = document.getElementById('dashSeriesDemographic');
         const dashSeriesGenre = document.getElementById('dashSeriesGenre');
         const dashSeriesSubGenre = document.getElementById('dashSeriesSubGenre');
         const dashSeriesSave   = document.getElementById('dashSeriesSave');
         const dashSeriesCancel = document.getElementById('dashSeriesCancel');
         const dashLibraryForm  = document.getElementById('dashLibraryForm');
         const dashDetailTitle  = document.getElementById('dashDetailTitle');
         const dashDetailRead   = document.getElementById('dashDetailRead');
         const dashDetailDatePurchased = document.getElementById('dashDetailDatePurchased');
         const dashDetailDateRead = document.getElementById('dashDetailDateRead');
         const dashDetailDateReadRow = document.getElementById('dashDetailDateReadRow');
         const dashDetailSave   = document.getElementById('dashDetailSave');
         const dashDetailCancel = document.getElementById('dashDetailCancel');
         
         const backToTopBtn    = document.getElementById('backToTop');
         const adminSettingsBtn = document.getElementById('adminSettingsBtn');
         const settingsOverlay = document.getElementById('settingsOverlay');
         const settingsClose = document.getElementById('settingsClose');
         const exportJsonBtn = document.getElementById('exportJsonBtn');
         const exportCsvBtn = document.getElementById('exportCsvBtn');
         const exportCoversBtn = document.getElementById('exportCoversBtn');
         const activityLogList = document.getElementById('activityLogList');
         
         const authSection     = document.getElementById('authSection');
         const authStatus      = document.getElementById('authStatus');
         const loginBtn        = document.getElementById('loginBtn');
         const logoutBtn       = document.getElementById('logoutBtn');
         
         const adminBar        = document.getElementById('adminBar');
         const adminAddLibrary = document.getElementById('adminAddLibrary');
         const adminAddWishlist= document.getElementById('adminAddWishlist');
         const adminMultiSelect   = document.getElementById('adminMultiSelect');
         const menuDashboard      = document.getElementById('menuDashboard');
         
         const multiSelectBar     = document.getElementById('multiSelectBar');
         const multiSelectInfo    = document.getElementById('multiSelectInfo');
         const multiSelectMove    = document.getElementById('multiSelectMove');
         const multiSelectMarkRead   = document.getElementById('multiSelectMarkRead');
         const multiSelectMarkUnread = document.getElementById('multiSelectMarkUnread');
         const multiSelectDelete  = document.getElementById('multiSelectDelete');
         const multiSelectCancel  = document.getElementById('multiSelectCancel');
         const multiSelectEdit    = document.getElementById('multiSelectEdit');
         
         
         const popupOverlay    = document.getElementById('popupOverlay');
         const popupContent    = document.getElementById('popupContent');
         const popupImage      = document.getElementById('popupImage');
         const popupTitle      = document.getElementById('popupTitle');
         const popupMeta       = document.getElementById('popupMeta');
         const popupISBN       = document.getElementById('popupISBN');
         const popupClose      = document.getElementById('popupClose');
         const popupBuy        = document.getElementById('popupBuy');
         const popupAdmin      = document.getElementById('popupAdminControls');
         const popupToggleRead = document.getElementById('popupToggleRead');
         const popupEdit       = document.getElementById('popupEdit');
         const popupDelete     = document.getElementById('popupDelete');
         
         // Admin form DOM refs
         const adminFormOverlay   = document.getElementById('adminFormOverlay');
         const adminFormCard      = document.getElementById('adminFormCard');
         const adminFormClose     = document.getElementById('adminFormClose');
         const adminFormTitle     = document.getElementById('adminFormTitle');
         const adminCoverPreview  = document.getElementById('adminCoverPreview');
         
         const adminTitleInput    = document.getElementById('adminTitleInput');
         const adminAuthorsInput  = document.getElementById('adminAuthorsInput');
         const adminPublisherInput= document.getElementById('adminPublisherInput');
         const adminTitleSuggestions    = document.getElementById('adminTitleSuggestions');
         const adminAuthorSuggestions   = document.getElementById('adminAuthorSuggestions');
         const adminPublisherSuggestions= document.getElementById('adminPublisherSuggestions');
         const adminMultiCreateBtn      = document.getElementById('adminMultiCreateBtn');
         const adminDateInput     = document.getElementById('adminDateInput');
         const adminIsbnInput     = document.getElementById('adminIsbnInput');
         const adminCoverInput    = document.getElementById('adminCoverInput');
         const adminAmazonWrapper = document.getElementById('adminAmazonWrapper');
         const adminAmazonInput   = document.getElementById('adminAmazonInput');
         const adminReadWrapper   = document.getElementById('adminReadWrapper');
         const adminReadInput     = document.getElementById('adminReadInput');
         const adminDateReadWrapper = document.getElementById('adminDateReadWrapper');
         const adminDateReadInput = document.getElementById('adminDateReadInput');
        const adminFormSave      = document.getElementById('adminFormSave');

        attachDateDropdowns(adminDateInput);
        attachDateDropdowns(adminDateReadInput);
        attachDateDropdowns(dashDetailDatePurchased);
        attachDateDropdowns(dashDetailDateRead);
        attachDateDropdowns(dashSeriesDatePurchased);
         
         // Multi-create editor DOM refs
         const multiEditorOverlay       = document.getElementById('multiEditorOverlay');
         const multiEditorClose         = document.getElementById('multiEditorClose');
         const multiEditorCoverPreview  = document.getElementById('multiEditorCoverPreview');
         const multiEditorSeriesLabel   = document.getElementById('multiEditorSeriesLabel');
         const multiEditorVolumeLabel   = document.getElementById('multiEditorVolumeLabel');
         const multiEditorPosition      = document.getElementById('multiEditorPosition');
         
         const multiEditorTitle         = document.getElementById('multiEditorTitle');
         const multiEditorTitleInput    = document.getElementById('multiEditorTitleInput');
         const multiEditorAuthorsInput  = document.getElementById('multiEditorAuthorsInput');
         const multiEditorPublisherInput= document.getElementById('multiEditorPublisherInput');
         const multiEditorDateInput     = document.getElementById('multiEditorDateInput');
         const multiEditorIsbnInput     = document.getElementById('multiEditorIsbnInput');
         const multiEditorCoverInput    = document.getElementById('multiEditorCoverInput');
         const multiEditorAmazonWrapper = document.getElementById('multiEditorAmazonWrapper');
         const multiEditorAmazonInput   = document.getElementById('multiEditorAmazonInput');
         const multiEditorReadWrapper   = document.getElementById('multiEditorReadWrapper');
         const multiEditorReadInput     = document.getElementById('multiEditorReadInput');
         const multiEditorDateReadWrapper = document.getElementById('multiEditorDateReadWrapper');
         const multiEditorDateReadInput   = document.getElementById('multiEditorDateReadInput');
         const multiEditorAddVolume     = document.getElementById('multiEditorAddVolume');
         const multiEditorPrev          = document.getElementById('multiEditorPrev');
         const multiEditorNext          = document.getElementById('multiEditorNext');
         const multiEditorSaveAll       = document.getElementById('multiEditorSaveAll');

         attachDateDropdowns(multiEditorDateInput);
         attachDateDropdowns(multiEditorDateReadInput);

        if (multiEditorReadInput && multiEditorDateReadInput) {
          multiEditorReadInput.addEventListener('change', () => {
            if (multiEditorReadInput.checked) {
              if (multiEditorDateReadWrapper) multiEditorDateReadWrapper.style.display = "flex";
              if (!multiEditorDateReadInput.value) {
                setDateInputValue(multiEditorDateReadInput, new Date().toISOString().slice(0,10));
              }
            } else {
              if (multiEditorDateReadWrapper) multiEditorDateReadWrapper.style.display = "none";
              setDateInputValue(multiEditorDateReadInput, "");
            }
          });
        }
         
         // Auth modal DOM refs
         const authModalOverlay      = document.getElementById('authModalOverlay');
         const authModalClose        = document.getElementById('authModalClose');
         const authTabSignIn         = document.getElementById('authTabSignIn');
         const authTabSignUp         = document.getElementById('authTabSignUp');
         const authSignInForm        = document.getElementById('authSignInForm');
         const authSignUpForm        = document.getElementById('authSignUpForm');
         const authError             = document.getElementById('authError');
         const authGoogleSignIn      = document.getElementById('authGoogleSignIn');
         const authForgotPassword    = document.getElementById('authForgotPassword');
         const signInEmail           = document.getElementById('signInEmail');
         const signInPassword        = document.getElementById('signInPassword');
         const signUpEmail           = document.getElementById('signUpEmail');
         const signUpPassword        = document.getElementById('signUpPassword');
         const signUpPasswordConfirm = document.getElementById('signUpPasswordConfirm');
         
         function formatDateMMDDYYYY(str) {
           if (!str) return '';
           const m = /^\s*(\d{4})-(\d{2})-(\d{2})\s*$/.exec(str);
           if (!m) return str;
           return `${m[2]}-${m[3]}-${m[1]}`;
         }

         function formatTimestamp(dt) {
           return dt.toLocaleString(undefined, { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
         }

         function renderActivityLog() {
           if (!activityLogList) return;
           activityLogList.innerHTML = '';
           if (!activityLog.length) {
             const empty = document.createElement('div');
             empty.className = 'activity-empty';
             empty.textContent = 'No recent activity';
             activityLogList.appendChild(empty);
             return;
           }
           activityLog.forEach(entry => {
             const row = document.createElement('div');
             row.className = 'activity-item';
             const txt = document.createElement('div');
             txt.className = 'activity-text';
             txt.textContent = entry.message;
             const time = document.createElement('div');
             time.className = 'activity-time';
             time.textContent = formatTimestamp(entry.ts);
             row.appendChild(txt);
             row.appendChild(time);
             activityLogList.appendChild(row);
           });
         }

         function addActivity(message) {
           if (!message) return;
           activityLog.unshift({ message, ts: new Date() });
           if (activityLog.length > 100) activityLog.pop();
           renderActivityLog();
         }

         function attachDateDropdowns(hiddenInput) {
           if (!hiddenInput || hiddenInput.__hasDateSelects) return;
           const parent = hiddenInput.parentElement;
           if (!parent) return;
           const row = document.createElement('div');
           row.className = 'date-select-row';
           parent.insertBefore(row, hiddenInput);
           row.appendChild(hiddenInput);
           hiddenInput.style.display = 'none';

           const makeSelect = () => {
             const sel = document.createElement('select');
             const optEmpty = document.createElement('option');
             optEmpty.value = '';
             optEmpty.textContent = '';
             optEmpty.hidden = true;
             optEmpty.disabled = true;
             optEmpty.selected = true;
             sel.appendChild(optEmpty);
             return sel;
           };

           const monthSel = makeSelect();
           const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
           monthNames.forEach((name, idx) => {
             const opt = document.createElement('option');
             opt.value = String(idx + 1).padStart(2, '0');
             opt.textContent = name;
             monthSel.appendChild(opt);
           });

           const daySel   = makeSelect();
           for (let i = 1; i <= 31; i++) {
             const opt = document.createElement('option');
             opt.value = String(i).padStart(2, '0');
             opt.textContent = String(i).padStart(2, '0');
             daySel.appendChild(opt);
           }

           const yearSel  = makeSelect();
           const nowYear = new Date().getFullYear();
           for (let y = nowYear + 5; y >= 1950; y--) {
             const opt = document.createElement('option');
             opt.value = String(y);
             opt.textContent = String(y);
             yearSel.appendChild(opt);
           }

           row.insertBefore(monthSel, hiddenInput);
           row.insertBefore(daySel, hiddenInput);
           row.insertBefore(yearSel, hiddenInput);

           function updateDayOptions(preserveSelection = true) {
             const y = parseInt(yearSel.value || '2000', 10);
             const m = parseInt(monthSel.value || '1', 10);
             const daysInMonth = new Date(y, m, 0).getDate();
             const prevDay = preserveSelection ? (daySel.value || '') : '';
             while (daySel.options.length > 1) daySel.remove(1);
             for (let d = 1; d <= daysInMonth; d++) {
               const opt = document.createElement('option');
               opt.value = String(d).padStart(2, '0');
               opt.textContent = String(d).padStart(2, '0');
               daySel.appendChild(opt);
             }
             if (prevDay) {
               const clamped = Math.min(parseInt(prevDay, 10), daysInMonth);
               const clampedVal = String(clamped).padStart(2, '0');
               daySel.value = clampedVal;
             }
           }

           function syncHidden() {
             const m = monthSel.value;
             const d = daySel.value;
             const y = yearSel.value;
             if (m && d && y) {
               hiddenInput.value = `${y}-${m}-${d}`;
             } else {
               hiddenInput.value = '';
             }
           }

           function syncSelectsFromHidden() {
             const val = hiddenInput.value || '';
             const m = /^\s*(\d{4})-(\d{2})-(\d{2})\s*$/.exec(val);
             updateDayOptions(false);
             if (m) {
               yearSel.value = m[1];
               monthSel.value = m[2];
               updateDayOptions(false);
               daySel.value = m[3];
             } else {
               yearSel.value = '';
               monthSel.value = '';
               updateDayOptions(false);
               daySel.value = '';
             }
           }

           monthSel.addEventListener('change', () => { updateDayOptions(); syncHidden(); });
           yearSel.addEventListener('change', () => { updateDayOptions(); syncHidden(); });
           daySel.addEventListener('change', syncHidden);

           hiddenInput.__syncDateSelects = syncSelectsFromHidden;
           hiddenInput.__setDateValue = (v) => {
             hiddenInput.value = v || '';
             syncSelectsFromHidden();
           };
           hiddenInput.__hasDateSelects = true;
           syncSelectsFromHidden();
         }

         function setDateInputValue(input, val) {
           if (!input) return;
           if (input.__setDateValue) {
             input.__setDateValue(val);
           } else {
             input.value = val || '';
           }
         }
         
         function updateMultiSelectInfo() {
           const count = multiSelectedIds.size;
           if (multiSelectInfo) {
             multiSelectInfo.textContent = `${count} selected`;
           }
         }
         
         function updateMultiSelectUI() {
           // Show/hide bar
           if (multiSelectBar) {
             multiSelectBar.style.display = (multiSelectActive && isAdmin) ? 'flex' : 'none';
           }
         
           // Toggle body class (if you want any page-wide styling)
           if (multiSelectActive && isAdmin) {
             document.body.classList.add('multi-select-active');
           } else {
             document.body.classList.remove('multi-select-active');
           }
         
           // Configure which actions are visible/labelled based on section
           const isLibraryPage = (currentSectionKey === 'library');
         
           if (multiSelectMove) {
             multiSelectMove.textContent = isLibraryPage ? 'Move to Wishlist' : 'Move to Library';
           }
         
           if (multiSelectMarkRead && multiSelectMarkUnread) {
             // Only meaningful in Library
             multiSelectMarkRead.style.display   = isLibraryPage ? 'inline-block' : 'none';
             multiSelectMarkUnread.style.display = isLibraryPage ? 'inline-block' : 'none';
           }
         
           updateMultiSelectInfo();
         }
         
         function exitMultiSelectMode() {
           multiSelectActive = false;
           multiSelectedIds.clear();
         
           // Remove highlight from all cards
           document.querySelectorAll('.card.multi-selected').forEach(card => {
             card.classList.remove('multi-selected');
           });
         
           updateMultiSelectUI();
         }
         
         function toggleCardSelection(card, id) {
           if (multiSelectedIds.has(id)) {
             multiSelectedIds.delete(id);
             card.classList.remove('multi-selected');
           } else {
             multiSelectedIds.add(id);
             card.classList.add('multi-selected');
           }
           updateMultiSelectInfo();
         }
         
         // ===== AUTH MODAL LOGIC =====
         function setAuthTab(tab) {
           const isSignIn = (tab === 'signin');
           if (!authTabSignIn || !authTabSignUp) return;
         
           authTabSignIn.classList.toggle('active', isSignIn);
           authTabSignUp.classList.toggle('active', !isSignIn);
         
           authSignInForm.classList.toggle('active', isSignIn);
           authSignUpForm.classList.toggle('active', !isSignIn);
         }
         
         function showAuthError(message) {
           if (!authError) return;
           authError.style.display = 'block';
           authError.textContent = message;
         }
         
         function clearAuthError() {
           if (!authError) return;
           authError.style.display = 'none';
           authError.textContent = '';
         }
         
         function openAuthModal(defaultTab = 'signin') {
           clearAuthError();
           setAuthTab(defaultTab === 'signup' ? 'signup' : 'signin');
           authModalOverlay.style.display = 'flex';
         }
         
         function closeAuthModal() {
           authModalOverlay.style.display = 'none';
         }
         
         // Tab switching
         if (authTabSignIn) {
           authTabSignIn.addEventListener('click', () => setAuthTab('signin'));
         }
         if (authTabSignUp) {
           authTabSignUp.addEventListener('click', () => setAuthTab('signup'));
         }
         
         // Close modal
         if (authModalClose) {
           authModalClose.addEventListener('click', closeAuthModal);
         }
         // Do not close the auth modal just by clicking the blurred backdrop (harder to dismiss accidentally).
         
         // Email / password SIGN IN
         if (authSignInForm) {
           authSignInForm.addEventListener('submit', async (e) => {
             e.preventDefault();
             clearAuthError();
         
             const email = (signInEmail.value || '').trim();
             const password = signInPassword.value || '';
         
             if (!email || !password) {
               showAuthError('Email and password are required.');
               return;
             }
         
             try {
               await signInWithEmailAndPassword(auth, email, password);
               // onAuthStateChanged will close the modal and set admin UI.
             } catch (err) {
               console.error('Sign-in error', err);
               showAuthError(err.message || 'Failed to sign in.');
             }
           });
         }
         
         // Email / password SIGN UP
         if (authSignUpForm) {
           authSignUpForm.addEventListener('submit', async (e) => {
             e.preventDefault();
             clearAuthError();
         
             const email = (signUpEmail.value || '').trim();
             const password = signUpPassword.value || '';
             const confirm = signUpPasswordConfirm.value || '';
         
             if (!email || !password) {
               showAuthError('Email and password are required.');
               return;
             }
             if (password !== confirm) {
               showAuthError('Passwords do not match.');
               return;
             }
         
             try {
               const cred = await createUserWithEmailAndPassword(auth, email, password);
               // create a user document with admin: false by default
               try {
                 await setDoc(doc(db, "users", cred.user.uid), {
                   email,
                   admin: false
                 });
               } catch (docErr) {
                 console.error('Failed to save user doc', docErr);
               }
               // User will now be signed in; onAuthStateChanged will run.
             } catch (err) {
               console.error('Sign-up error', err);
               showAuthError(err.message || 'Failed to create account.');
             }
           });
         }
         
         // Forgot password
         if (authForgotPassword) {
           authForgotPassword.addEventListener('click', async () => {
             clearAuthError();
             const email = (signInEmail.value || '').trim();
             if (!email) {
               showAuthError('Enter your email above before using "Forgot password?".');
               return;
             }
             try {
               await sendPasswordResetEmail(auth, email);
               showAuthError('Password reset email sent (check your inbox).');
             } catch (err) {
               console.error('Password reset error', err);
               showAuthError(err.message || 'Failed to send reset email.');
             }
           });
         }
         
         // Google sign-in from inside modal
         if (authGoogleSignIn) {
           authGoogleSignIn.addEventListener('click', async () => {
             clearAuthError();
             try {
               await signInWithPopup(auth, provider);
               // onAuthStateChanged will handle the rest
             } catch (err) {
               console.error('Google sign-in error', err);
               showAuthError(err.message || 'Google sign-in failed.');
             }
           });
         }
         
         
         // state for current form usage
         let adminFormMode = "add"; // "add" or "edit"
         let adminFormCollection = "library"; // "library" or "wishlist"
         let adminFormDocId = null;
         
         // ===== HAMBURGER MENU =====
         menuToggle.addEventListener('click', () => {
           menuToggle.classList.toggle('active');
           menuPanel.classList.toggle('open');
         });

         function openSettings() {
           if (settingsOverlay) settingsOverlay.style.display = 'flex';
         }
         function closeSettings() {
           if (settingsOverlay) settingsOverlay.style.display = 'none';
         }
         if (adminSettingsBtn) {
           adminSettingsBtn.addEventListener('click', openSettings);
         }
         if (settingsClose) {
           settingsClose.addEventListener('click', closeSettings);
         }
         if (settingsOverlay) {
           settingsOverlay.addEventListener('click', (e) => {
             if (e.target === settingsOverlay) closeSettings();
           });
         }
         if (calendarPrevBtn) {
           calendarPrevBtn.addEventListener('click', () => shiftCalendarMonth(-1));
         }
         if (calendarNextBtn) {
           calendarNextBtn.addEventListener('click', () => shiftCalendarMonth(1));
         }
         if (exportJsonBtn) {
           exportJsonBtn.addEventListener('click', () => {
             exportToJSON();
             closeSettings();
           });
         }
         if (exportCsvBtn) {
           exportCsvBtn.addEventListener('click', () => {
             exportToCSV();
             closeSettings();
           });
         }
         if (exportCoversBtn) {
           exportCoversBtn.addEventListener('click', () => {
             exportCoversZip();
             // leave settings open while processing for feedback
           });
         }
         
           function handleTitleInputChange() {
           renderTitleSuggestions();
           renderAuthorPublisherSuggestions();
           updateMultiCreateVisibility();
         }
         
         function handleAuthorsInputChange() {
           renderAuthorPublisherSuggestions();
         }
         
         function handlePublisherInputChange() {
           renderAuthorPublisherSuggestions();
         }
         
         if (adminTitleInput) {
           adminTitleInput.addEventListener('input', handleTitleInputChange);
         }
         if (adminAuthorsInput) {
           adminAuthorsInput.addEventListener('input', handleAuthorsInputChange);
         }
         if (adminPublisherInput) {
           adminPublisherInput.addEventListener('input', handlePublisherInputChange);
         }
         
         function updateMultiCreateVisibility() {
           if (!adminMultiCreateBtn) return;
           const t = adminTitleInput.value.trim();
           if (/(Vol\.|Volume)\s*\d+/i.test(t)) {
             adminMultiCreateBtn.style.display = 'inline-block';
           } else {
             adminMultiCreateBtn.style.display = 'none';
           }
         }
         
        if (adminMultiCreateBtn) {
          adminMultiCreateBtn.addEventListener("click", () => {
            const suggestion = computeSeriesSuggestionFromTitleInput();
            if (!suggestion) {
              alert("Type a recognizable series title (e.g. 'Assassination Classroom, Vol. 1') so I can detect volumes.");
              return;
            }
            openMultiEditorFromSuggestion(suggestion);
          });
        }

        function getSeriesDisplayNameFromTitle(title) {
          const t = title || "";
          const m = t.match(/^(.*?)(?:,?\s*(?:Vol\.|Volume)\s*\d+)?$/i);
          const name = m ? m[1].trim() : t.trim();
          return name || "Untitled";
        }

        function getSeriesKey(book) {
          if (!book) return "";
          const parsed = parseTitleForSort(book.Title);
          if (parsed.vol && parsed.name) return parsed.name;
          return (book.Title || "").trim().toLowerCase() || (book.id || "");
        }

        function buildSeriesGroups() {
          const map = new Map();
          libraryBooks.forEach(b => {
            const key = getSeriesKey(b);
            const displayName = getSeriesDisplayNameFromTitle(b.Title);
            if (!map.has(key)) {
              map.set(key, { seriesKey: key, displayName, books: [] });
            }
            map.get(key).books.push(b);
          });
          dashGroupedSeries = Array.from(map.values()).sort((a, b) => a.displayName.localeCompare(b.displayName));
          dashGroupedSeries.forEach(group => {
            group.books.sort((a, b) => {
              const aP = parseTitleForSort(a.Title);
              const bP = parseTitleForSort(b.Title);
              const nameCmp = aP.name.localeCompare(bP.name);
              if (nameCmp !== 0) return nameCmp;
              if (aP.vol !== bP.vol) return aP.vol - bP.vol;
              return (a.Title || "").localeCompare(b.Title || "");
            });
          });
        }

        function renderDashboardLibraryList() {
          if (!dashLibraryList) return;
          buildSeriesGroups();
          dashLibraryList.innerHTML = "";
          if (!dashGroupedSeries.length) {
            dashLibraryList.textContent = "No library items";
            if (dashLibraryEmpty) dashLibraryEmpty.style.display = "block";
            if (dashLibraryForm) dashLibraryForm.style.display = "none";
            if (dashSeriesForm) dashSeriesForm.style.display = "none";
            return;
          }

          dashGroupedSeries.forEach(group => {
            const seriesDiv = document.createElement('div');
            seriesDiv.className = 'dash-series';
            if (dashSeriesExpanded.has(group.seriesKey)) seriesDiv.classList.add('expanded');

            const header = document.createElement('button');
            header.className = 'dash-series-header';
            if (group.seriesKey === dashSelectedSeriesKey && !dashSelectedBookId) {
              header.classList.add('active');
            }
            const readCount = group.books.filter(b => b.Read).length;

            const chevron = document.createElement('span');
            chevron.className = 'dash-series-chevron';
            chevron.textContent = '';

            const titleSpan = document.createElement('span');
            titleSpan.className = 'dash-series-title';
            titleSpan.textContent = group.displayName;

            const metaSpan = document.createElement('span');
            metaSpan.className = 'dash-series-meta';
            metaSpan.textContent = `${group.books.length} book${group.books.length !== 1 ? 's' : ''}${group.books.length ? '  ' + readCount + ' read' : ''}`;

            header.appendChild(chevron);
            header.appendChild(titleSpan);
            header.appendChild(metaSpan);

            // Select the series (without toggling expansion)
            header.addEventListener('click', () => {
              dashSelectedSeriesKey = group.seriesKey;
              dashSelectedBookId = null;
              openSeriesDetail(group.seriesKey);
              renderDashboardLibraryList();
            });

            // Only expand/collapse when clicking the chevron
            chevron.addEventListener('click', (e) => {
              e.stopPropagation();
              if (dashSeriesExpanded.has(group.seriesKey)) {
                dashSeriesExpanded.delete(group.seriesKey);
              } else {
                dashSeriesExpanded.add(group.seriesKey);
              }
              dashSelectedSeriesKey = group.seriesKey;
              dashSelectedBookId = null;
              openSeriesDetail(group.seriesKey);
              renderDashboardLibraryList();
            });

            seriesDiv.appendChild(header);

            const booksWrap = document.createElement('div');
            booksWrap.className = 'dash-series-books';
            group.books.forEach(book => {
              const btn = document.createElement('button');
              btn.textContent = `${book.Title || 'Untitled'}${book.Read ? ' ' : ''}`;
              if (book.id === dashSelectedBookId) btn.classList.add('active');
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                dashSelectedBookId = book.id;
                dashSelectedSeriesKey = group.seriesKey;
                dashSeriesExpanded.add(group.seriesKey);
                openDashboardDetail(book.id);
                renderDashboardLibraryList();
              });
              booksWrap.appendChild(btn);
            });
            seriesDiv.appendChild(booksWrap);
            dashLibraryList.appendChild(seriesDiv);
          });
        }

        function openSeriesDetail(seriesKey) {
          const group = dashGroupedSeries.find(g => g.seriesKey === seriesKey);
          dashSelectedSeriesKey = seriesKey;
          dashSelectedBookId = null;
          if (!group) {
            if (dashLibraryEmpty) dashLibraryEmpty.style.display = "block";
            if (dashSeriesForm) dashSeriesForm.style.display = "none";
            if (dashLibraryForm) dashLibraryForm.style.display = "none";
            return;
          }
          if (dashLibraryEmpty) dashLibraryEmpty.style.display = "none";
          if (dashSeriesForm) dashSeriesForm.style.display = "block";
          if (dashLibraryForm) dashLibraryForm.style.display = "none";

          if (dashSeriesTitle) dashSeriesTitle.textContent = group.displayName;

          const readCount = group.books.filter(b => b.Read).length;
          const allRead = readCount === group.books.length && group.books.length > 0;
          const allUnread = readCount === 0;
          if (dashSeriesRead) {
            dashSeriesRead.checked = allRead;
            dashSeriesRead.indeterminate = !allRead && !allUnread;
          }

          // Shared string fields (publisher, demographic, genre, subGenre)
          const assignSharedField = (el, valuesArray) => {
            if (!el) return;
            const unique = Array.from(new Set(valuesArray.map(v => (v || "").trim())));
            const val = unique.length === 1 ? unique[0] : "";
            el.value = val;
            el.dataset.initialValue = el.value || "";
          };

          assignSharedField(dashSeriesPublisher, group.books.map(b => b.Publisher));
          assignSharedField(dashSeriesDemographic, group.books.map(b => b.Demographic));
          assignSharedField(dashSeriesGenre, group.books.map(b => b.Genre));
          assignSharedField(dashSeriesSubGenre, group.books.map(b => b.SubGenre));

          if (dashSeriesDatePurchased) {
            const dpValues = Array.from(new Set(group.books.map(b => (b.DatePurchased || "").trim())));
            const dpVal = dpValues.length === 1 ? dpValues[0] : "";
            if (dpValues.length <= 1) {
              if (dashSeriesDatePurchasedRow) dashSeriesDatePurchasedRow.style.display = "flex";
              setDateInputValue(dashSeriesDatePurchased, dpVal);
              dashSeriesDatePurchased.dataset.initialValue = dashSeriesDatePurchased.value || "";
            } else {
              // Different dates across books: hide the series date control
              if (dashSeriesDatePurchasedRow) dashSeriesDatePurchasedRow.style.display = "none";
              setDateInputValue(dashSeriesDatePurchased, "");
              dashSeriesDatePurchased.dataset.initialValue = "";
            }
          }

          if (dashSeriesMSRP) {
            const msrpValues = Array.from(new Set(group.books.map(b => {
              const v = b.MSRP;
              return (v === undefined || v === null || v === "") ? "" : String(v);
            })));
            const msrpVal = msrpValues.length === 1 ? msrpValues[0] : "";
            dashSeriesMSRP.value = msrpVal;
            dashSeriesMSRP.dataset.initialValue = dashSeriesMSRP.value || "";
          }
        }

        function openDashboardDetail(id) {
          const book = libraryBooks.find(x => x.id === id);
          if (!book) {
            dashSelectedBookId = null;
            if (dashLibraryEmpty) dashLibraryEmpty.style.display = "block";
            if (dashLibraryForm) dashLibraryForm.style.display = "none";
            if (dashSeriesForm) dashSeriesForm.style.display = "none";
            return;
          }
          const seriesKey = getSeriesKey(book);
          dashSelectedSeriesKey = seriesKey;
          dashSeriesExpanded.add(seriesKey);

          if (dashLibraryEmpty) dashLibraryEmpty.style.display = "none";
          if (dashLibraryForm) dashLibraryForm.style.display = "block";
          if (dashSeriesForm) dashSeriesForm.style.display = "none";
          if (dashDetailTitle) dashDetailTitle.textContent = book.Title || "Untitled";
          if (dashDetailRead) dashDetailRead.checked = !!book.Read;
          if (dashDetailDatePurchased) setDateInputValue(dashDetailDatePurchased, book.DatePurchased || "");
          if (dashDetailDateRead) setDateInputValue(dashDetailDateRead, book.Read ? (book.DateRead || "") : "");
          if (dashDetailDateReadRow) dashDetailDateReadRow.style.display = book.Read ? "block" : "none";
          if (dashDetailMSRP) dashDetailMSRP.value = (book.MSRP !== undefined && book.MSRP !== null && book.MSRP !== "") ? book.MSRP : "";
        }

        if (dashDetailRead && dashDetailDateReadRow) {
          dashDetailRead.addEventListener('change', () => {
            if (dashDetailRead.checked) {
              dashDetailDateReadRow.style.display = "block";
              if (dashDetailDateRead && !dashDetailDateRead.value) {
                setDateInputValue(dashDetailDateRead, new Date().toISOString().slice(0,10));
              }
            } else {
              dashDetailDateReadRow.style.display = "none";
              if (dashDetailDateRead) setDateInputValue(dashDetailDateRead, "");
            }
          });
        }

        if (dashSeriesRead) {
          dashSeriesRead.addEventListener('change', () => {
            dashSeriesRead.indeterminate = false;
          });
        }

        if (dashDetailCancel) {
          dashDetailCancel.addEventListener('click', () => {
            dashSelectedBookId = null;
            if (dashLibraryForm) dashLibraryForm.style.display = "none";
            if (dashLibraryEmpty) dashLibraryEmpty.style.display = "block";
            renderDashboardLibraryList();
          });
        }

        if (dashDetailSave) {
          dashDetailSave.addEventListener('click', async () => {
            if (!dashSelectedBookId) return;
            const readVal = dashDetailRead ? !!dashDetailRead.checked : false;
            const dp = dashDetailDatePurchased ? dashDetailDatePurchased.value.trim() : "";
            const drRaw = dashDetailDateRead ? dashDetailDateRead.value.trim() : "";
            const dr = readVal ? ( /^\d{4}-\d{2}-\d{2}$/.test(drRaw) ? drRaw : new Date().toISOString().slice(0,10) ) : "";
            const msrpRaw = dashDetailMSRP ? dashDetailMSRP.value.trim() : "";
            const msrpNum = msrpRaw === "" ? "" : parseFloat(msrpRaw);
            const payload = {
              datePurchased: dp || "",
              read: readVal,
              dateRead: dr,
              msrp: msrpRaw === "" ? "" : (Number.isFinite(msrpNum) ? msrpNum : "")
            };
            try {
              await updateDoc(doc(db, "library", dashSelectedBookId), payload);
              await loadLibraryFromFirestore();
              renderDashboardLibraryList();
              openDashboardDetail(dashSelectedBookId);
              alert("Saved changes.");
              const editedBook = libraryBooks.find(b => b.id === dashSelectedBookId);
              if (editedBook) {
                addActivity(`Updated "${editedBook.Title || 'Untitled'}" in library`);
              }
            } catch (err) {
              console.error(err);
              alert("Failed to save changes.");
            }
          });
        }

        async function saveSeriesChanges() {
          if (!dashSelectedSeriesKey) return;
          const group = dashGroupedSeries.find(g => g.seriesKey === dashSelectedSeriesKey);
          if (!group || !group.books.length) return;

          const applyRead = dashSeriesRead ? !dashSeriesRead.indeterminate : false;
          const newReadVal = dashSeriesRead ? !!dashSeriesRead.checked : false;

          const dpInput = dashSeriesDatePurchased ? dashSeriesDatePurchased.value.trim() : "";
          const dpInitial = dashSeriesDatePurchased ? (dashSeriesDatePurchased.dataset.initialValue || "") : "";
          const dpChanged = dashSeriesDatePurchased ? (dpInput !== dpInitial) : false;

          const msrpInput = dashSeriesMSRP ? dashSeriesMSRP.value.trim() : "";
          const msrpInitial = dashSeriesMSRP ? (dashSeriesMSRP.dataset.initialValue || "") : "";
          const msrpChanged = dashSeriesMSRP ? (msrpInput !== msrpInitial) : false;
          const msrpNumber = msrpInput === "" ? "" : parseFloat(msrpInput);
          const msrpValue = msrpInput === "" ? "" : (Number.isFinite(msrpNumber) ? msrpNumber : "");

          const pubVal = dashSeriesPublisher ? dashSeriesPublisher.value.trim() : "";
          const pubChanged = dashSeriesPublisher ? (pubVal !== (dashSeriesPublisher.dataset.initialValue || "")) : false;
          const demoVal = dashSeriesDemographic ? dashSeriesDemographic.value.trim() : "";
          const demoChanged = dashSeriesDemographic ? (demoVal !== (dashSeriesDemographic.dataset.initialValue || "")) : false;
          const genreVal = dashSeriesGenre ? dashSeriesGenre.value.trim() : "";
          const genreChanged = dashSeriesGenre ? (genreVal !== (dashSeriesGenre.dataset.initialValue || "")) : false;
          const subVal = dashSeriesSubGenre ? dashSeriesSubGenre.value.trim() : "";
          const subChanged = dashSeriesSubGenre ? (subVal !== (dashSeriesSubGenre.dataset.initialValue || "")) : false;

          const updates = [];
          for (const book of group.books) {
            const payload = {};
            if (applyRead) {
              payload.read = newReadVal;
              payload.dateRead = newReadVal
                ? (book.DateRead && /^\d{4}-\d{2}-\d{2}$/.test(book.DateRead) ? book.DateRead : new Date().toISOString().slice(0,10))
                : "";
            }
            if (dpChanged) {
              payload.datePurchased = dpInput;
            }
            if (msrpChanged) {
              payload.msrp = msrpValue;
            }
            if (pubChanged) {
              payload.publisher = pubVal || "";
            }
            if (demoChanged) {
              payload.demographic = demoVal || "";
            }
            if (genreChanged) {
              payload.genre = genreVal || "";
            }
            if (subChanged) {
              payload.subGenre = subVal || "";
            }
            if (Object.keys(payload).length) {
              updates.push(updateDoc(doc(db, "library", book.id), payload));
            }
          }

          if (!updates.length) return;

          try {
            await Promise.all(updates);
            await loadLibraryFromFirestore();
            // Keep current selection without auto-expanding everything after save
            renderDashboardLibraryList();
            if (dashSelectedSeriesKey) {
              openSeriesDetail(dashSelectedSeriesKey);
            }
            alert("Series updated.");
            const groupName = group.displayName || 'Series';
            addActivity(`Updated series "${groupName}" (${group.books.length} book${group.books.length === 1 ? '' : 's'})`);
          } catch (err) {
            console.error(err);
            alert("Failed to update series.");
          }
        }

        if (dashSeriesSave) {
          dashSeriesSave.addEventListener('click', saveSeriesChanges);
        }

        if (dashSeriesCancel) {
          dashSeriesCancel.addEventListener('click', () => {
            dashSelectedSeriesKey = null;
            dashSelectedBookId = null;
            if (dashSeriesForm) dashSeriesForm.style.display = "none";
            if (dashLibraryForm) dashLibraryForm.style.display = "none";
            if (dashLibraryEmpty) dashLibraryEmpty.style.display = "block";
            renderDashboardLibraryList();
          });
        }

        if (adminReadInput && adminDateReadInput) {
          const syncAdminReadDateUI = () => {
            if (adminReadInput.checked) {
              if (adminDateReadWrapper) adminDateReadWrapper.style.display = "block";
              if (!adminDateReadInput.value) {
                setDateInputValue(adminDateReadInput, new Date().toISOString().slice(0,10));
              }
            } else {
              if (adminDateReadWrapper) adminDateReadWrapper.style.display = "none";
              setDateInputValue(adminDateReadInput, "");
            }
          };
          adminReadInput.addEventListener('change', syncAdminReadDateUI);
          syncAdminReadDateUI();
        }
         
        function switchSection(target) {
          // Block dashboard for non-admins
          if (target === 'dashboard' && !isAdmin) {
            alert('Dashboard is for admins only.');
            return;
          }
          currentSectionKey = target === 'wishlist' ? 'wishlist'
                           : target === 'dashboard' ? 'dashboard'
                           : 'library';
          // Remember selection for this tab only (clears when tab closes)
          sessionStorage.setItem('lastSection', currentSectionKey);
         
          if (target === 'library') {
            pageTitle.textContent = "Tyler's Manga Library";
            librarySection.classList.add('active');
            librarySection.classList.remove('hidden');
            wishlistSection.classList.remove('active');
            wishlistSection.classList.add('hidden');
            if (dashboardSection) {
              dashboardSection.classList.add('hidden');
              dashboardSection.classList.remove('active');
            }
          } else if (target === 'dashboard') {
            pageTitle.textContent = "Dashboard";
            librarySection.classList.remove('active');
            librarySection.classList.add('hidden');
            wishlistSection.classList.remove('active');
            wishlistSection.classList.add('hidden');
            if (dashboardSection) {
              dashboardSection.classList.add('active');
              dashboardSection.classList.remove('hidden');
            }
            updateDashboardStats();
          } else {
            pageTitle.textContent = "Wishlist";
            librarySection.classList.remove('active');
            librarySection.classList.add('hidden');
            wishlistSection.classList.add('active');
            wishlistSection.classList.remove('hidden');
            if (dashboardSection) {
              dashboardSection.classList.add('hidden');
              dashboardSection.classList.remove('active');
            }
          }
         
           // Reset multi-select when switching sections
           multiSelectActive = false;
           multiSelectedIds.clear();
           updateMultiSelectUI();
         
           menuToggle.classList.remove('active');
           menuPanel.classList.remove('open');
         }
         
         document.querySelectorAll('.menu-item').forEach(btn => {
           btn.addEventListener('click', () => {
             const target = btn.getAttribute('data-target');
             switchSection(target);
           });
         });
         
         // Restore last section for this tab on refresh; default to library on new tab
         const savedSection = sessionStorage.getItem('lastSection');
         if (savedSection === 'wishlist' || savedSection === 'dashboard') {
           if (savedSection === 'dashboard' && !isAdmin) {
             switchSection('library');
           } else {
             switchSection(savedSection);
           }
         }
         
         // ===== SECRET SIGN-IN TRIGGER (Total Books clicked 5x) =====
         function handleSecretClick() {
           secretClickCount++;
           if (secretTimer) clearTimeout(secretTimer);
           secretTimer = setTimeout(() => {
             secretClickCount = 0;
           }, 2000); // 2s window
         
           if (secretClickCount >= 5) {
             authSection.style.display = "block";  // reveals secret sign-in on menu
             secretClickCount = 0;
             // If already signed in, just reveal the menu section; don't pop the modal.
             if (!auth.currentUser) {
               openAuthModal('signin');
             }
           }
         }
         
         totalTop.addEventListener('click', handleSecretClick);
         
         // ===== SORTING: Series  Vol # =====
         function parseTitleForSort(t) {
           t = (t || "").trim();
           const m = t.match(/^(.*?),?\s*(?:Vol\.|Volume)\s*(\d+)\b/i);
           if (!m) return { name: t.toLowerCase(), vol: 0 };
           return {
             name: m[1].trim().toLowerCase(),
             vol: parseInt(m[2] || "0", 10)
           };
         }
         
         function formatSeriesTitle(baseName, volNumber) {
           // baseName is lowercased inside parse; so we re-capitalize from current input when possible
           // but for safety, just ensure there's no trailing comma spacing issues
           const cleanBase = baseName.replace(/,\s*$/, '');
           return `${cleanBase}, Vol. ${volNumber}`;
         }
         
         function computeSeriesSuggestionFromTitleInput() {
           const input = adminTitleInput.value.trim().toLowerCase();
           currentSeriesSuggestion = null;
           if (!input) return null;
         
           const all = libraryBooks.concat(wishlistItems);
           const seriesMap = new Map(); // baseName -> { volumes:Set, authors:Map, publishers:Map }
         
           all.forEach(b => {
             if (!b.Title) return;
             const parsed = parseTitleForSort(b.Title);
             if (!parsed.name || !parsed.vol) return;
             if (!parsed.name.startsWith(input.replace(/,?\s*(vol\.|volume)\s*\d+/i, '').trim())) return;
         
         
               let entry = seriesMap.get(parsed.name);
               if (!entry) {
                   entry = {
                       volumes: new Set(),
                       authors: new Map(),
                       publishers: new Map(),
                       displayName: null  //  NEW
                   };
                   seriesMap.set(parsed.name, entry);
               }
         
               // Capture proper capitalization from the first matching book.
               if (!entry.displayName) {
                   // Extract series name part from actual Title
                   const titleMatch = (b.Title || "").match(/^(.*?)(?:,?\s*(?:Vol\.|Volume)\s*\d+)?$/i);
                   if (titleMatch) {
                       entry.displayName = titleMatch[1].trim();
                   }
               }
         
               entry.volumes.add(parsed.vol);
         
         
             if (b.Authors && b.Authors !== 'Unknown') {
               entry.authors.set(b.Authors, (entry.authors.get(b.Authors) || 0) + 1);
             }
             if (b.Publisher && b.Publisher !== 'Unknown') {
               entry.publishers.set(b.Publisher, (entry.publishers.get(b.Publisher) || 0) + 1);
             }
           });
         
           if (!seriesMap.size) return null;
         
           // pick the "best" series = the one with the most volumes
           let bestName = null;
           let bestEntry = null;
           for (const [name, entry] of seriesMap.entries()) {
             if (!bestEntry || entry.volumes.size > bestEntry.volumes.size) {
               bestName = name;
               bestEntry = entry;
             }
           }
         
           if (!bestEntry || !bestEntry.volumes.size) return null;
         
           const vols = Array.from(bestEntry.volumes).sort((a, b) => a - b);
           const maxVol = vols[vols.length - 1];
         
           // Missing volumes between 1..maxVol
           const missing = [];
           for (let v = 1; v <= maxVol; v++) {
             if (!bestEntry.volumes.has(v)) missing.push(v);
           }
         
           const nextVol = maxVol + 1;
           const suggestionVolumes = missing.concat([nextVol]); // only missing + next (as requested)
         
           if (!suggestionVolumes.length) return null;
         
           const pickMostCommon = (map) => {
             let bestKey = null;
             let bestCount = 0;
             for (const [k, cnt] of map.entries()) {
               if (cnt > bestCount) {
                 bestKey = k;
                 bestCount = cnt;
               }
             }
             return bestKey;
           };
         
           const suggestedAuthor    = pickMostCommon(bestEntry.authors)    || "";
           const suggestedPublisher = pickMostCommon(bestEntry.publishers) || "";
         
           currentSeriesSuggestion = {
               baseName: bestName,
               displayName: bestEntry.displayName,   //  NEW
               suggestionVolumes,
               author: suggestedAuthor,
               publisher: suggestedPublisher
           };
           return currentSeriesSuggestion;
         }
         
         function renderTitleSuggestions() {
           if (!adminTitleSuggestions) return;
           adminTitleSuggestions.innerHTML = "";
           adminTitleSuggestions.style.display = "none";
         
           const s = computeSeriesSuggestionFromTitleInput();
           if (!s) return;
         
           // only show after user started typing
           if (!adminTitleInput.value.trim()) return;
         
           const volsToShow = s.suggestionVolumes.slice(0, 10);
           if (!volsToShow.length) return;
         
           adminTitleSuggestions.style.display = "flex";
         
           volsToShow.forEach(v => {
               const chip = document.createElement('button');
               chip.type = 'button';
               chip.className = 'suggestion-chip';
         
               const cleanBase = (s.displayName || s.baseName).replace(/,\s*$/, '');
               chip.textContent = `${cleanBase}, Vol. ${v}`;
         
               chip.addEventListener('click', () => {
                   const proper = (s.displayName || s.baseName).replace(/,\s*$/, '');
                   adminTitleInput.value = `${proper}, Vol. ${v}`;
         
                   if (s.author && !adminAuthorsInput.value.trim())
                       adminAuthorsInput.value = s.author;
         
                   if (s.publisher && !adminPublisherInput.value.trim())
                       adminPublisherInput.value = s.publisher;
         
                   renderTitleSuggestions();
                   renderAuthorPublisherSuggestions();
                   updateMultiCreateVisibility();
               });
         
               adminTitleSuggestions.appendChild(chip);
           });
         }
         
         function renderAuthorPublisherSuggestions() {
           const s = currentSeriesSuggestion;
           // Authors
           if (adminAuthorSuggestions) {
             adminAuthorSuggestions.innerHTML = "";
             adminAuthorSuggestions.style.display = "none";
         
             if (s && s.author && adminAuthorsInput.value.trim().length > 0) {
               const chip = document.createElement('button');
               chip.type = 'button';
               chip.className = 'suggestion-chip';
               chip.textContent = s.author;
               chip.addEventListener('click', () => {
                 adminAuthorsInput.value = s.author;
                 renderAuthorPublisherSuggestions();
               });
               adminAuthorSuggestions.appendChild(chip);
               adminAuthorSuggestions.style.display = "flex";
             }
           }
         
           // Publisher
           if (adminPublisherSuggestions) {
             adminPublisherSuggestions.innerHTML = "";
             adminPublisherSuggestions.style.display = "none";
         
             if (s && s.publisher && adminPublisherInput.value.trim().length > 0) {
               const chip = document.createElement('button');
               chip.type = 'button';
               chip.className = 'suggestion-chip';
               chip.textContent = s.publisher;
               chip.addEventListener('click', () => {
                 adminPublisherInput.value = s.publisher;
                 renderAuthorPublisherSuggestions();
               });
               adminPublisherSuggestions.appendChild(chip);
               adminPublisherSuggestions.style.display = "flex";
             }
           }
         }
         
         function openMultiEditorFromSuggestion(s) {
           // s = { baseName, displayName, suggestionVolumes, author, publisher }
         
           if (!s || !s.suggestionVolumes || !s.suggestionVolumes.length) {
               alert("No volumes to create.");
               return;
           }
         
           // Build full list FIRST (existing + missing + nextVol)
           const fullList = computeFullVolumeList(s);
         
           // Open the fullscreen multi-editor with the correct full list
           openMultiCreateFullscreenEditor({
               ...s,
               fullList
           });
         }
         
         function computeFullVolumeList(s) {
           const allBooks = libraryBooks.concat(wishlistItems);
         
           const result = [];
         
           // 1. First load already-existing volumes with full data
           allBooks.forEach(b => {
               const parsed = parseTitleForSort(b.Title);
               if (parsed.name === s.baseName && parsed.vol > 0) {
                  result.push({
                      vol: parsed.vol,
                      title: b.Title,
                      authors: b.Authors,
                      publisher: b.Publisher,
                      date: b.Date,
                      isbn: b.ISBN,
                      cover: b.Cover,
                      amazonURL: b.AmazonURL || "",
                      read: !!b.Read,
                      dateRead: b.DateRead || "",
                      existsAlready: true,
                      docId: b.id
                  });
              }
          });
         
           // 2. Add volumes the user does NOT have yet (missing + next vol)
           s.suggestionVolumes.forEach(v => {
               if (!result.find(r => r.vol === v)) {
                   result.push({
                       vol: v,
                       title: `${s.displayName || s.baseName}, Vol. ${v}`,
                       authors: s.author || "",
                       publisher: s.publisher || "",
                       date: "",
                       isbn: "",
                       cover: "",
                       amazonURL: "",
                       read: false,
                       dateRead: "",
                       existsAlready: false,
                       docId: null
                   });
               }
           });
         
           // Sort by volume number
           result.sort((a, b) => a.vol - b.vol);
         
           return result;
         }
         
         function openMultiCreateFullscreenEditor(s) {
           // s = { baseName, displayName, suggestionVolumes, author, publisher }
         
           multiEditorMode = 'series';
           multiCreateActive = true;
           const fullList = s.fullList;  // passed from openMultiEditorFromSuggestion()
         
           multiCreateItems = fullList.map(item => ({
               title: item.title,
               authors: item.authors,
               publisher: item.publisher,
               date: /^\d{4}-\d{2}-\d{2}$/.test(item.date) ? item.date : "",
               isbn: item.isbn,
               cover: item.cover,
               amazonURL: item.amazonURL,
               read: item.read,
               dateRead: /^\d{4}-\d{2}-\d{2}$/.test(item.dateRead || "") ? item.dateRead : "",
               vol: item.vol,
               existsAlready: item.existsAlready,
               docId: item.docId || null
           }));
         
         
           multiCreateVolumes = fullList.map(item => item.vol);
           multiCreateIndex = 0;
         
         
           // Show the overlay
           multiEditorOverlay.style.display = "flex";
         
           loadCurrentMultiCreateEntry();
         }
         
         function openMultiEditForSelection() {
           const ids = Array.from(multiSelectedIds);
           if (!ids.length) {
               alert('Select at least one item first.');
               return;
           }
         
           const isLibraryPage = (currentSectionKey === 'library');
           const sourceArray = isLibraryPage ? libraryBooks : wishlistItems;
         
           const items = [];
           ids.forEach(id => {
               const b = sourceArray.find(x => x.id === id);
               if (!b) return;
         
              const existingDate = (b.Date || "").trim();
              const dateValue = /^\d{4}-\d{2}-\d{2}$/.test(existingDate)
                  ? existingDate
                  : "";
              const parsed = parseTitleForSort(b.Title);

              items.push({
                  title: b.Title || "",
                  authors: b.Authors || "",
                  publisher: b.Publisher || "",
                  date: dateValue,
                  isbn: b.ISBN || "",
                  cover: b.Cover || "",
                  amazonURL: b.AmazonURL || "",
                  read: !!b.Read,
                  dateRead: b.DateRead || "",
                  // Capture parsed sort info so numeric volumes stay in order (1,2,3...10)
                  sortName: parsed.name || (b.Title || "").toLowerCase(),
                  sortVol: parsed.vol || 0,
                  vol: parsed.vol || 0, // still unused for UI, but preserved for consistency
                  existsAlready: true,
                  docId: b.id
              });
           });
         
           if (!items.length) {
               alert('Could not load selected items.');
               return;
           }
         
           // Sort by series/name, then numeric volume, then title to avoid 1,10,2 ordering
           items.sort((a, b) => {
               const nameCmp = (a.sortName || '').localeCompare(b.sortName || '');
               if (nameCmp !== 0) return nameCmp;
               const volCmp = (a.sortVol || 0) - (b.sortVol || 0);
               if (volCmp !== 0) return volCmp;
               return (a.title || '').localeCompare(b.title || '');
           });
         
           multiCreateItems   = items;
           multiCreateVolumes = items.map((_, i) => i + 1);
           multiCreateIndex   = 0;
           multiEditorMode    = 'selection';
         
           // Ensure collection is correct so Save All knows where to update
           adminFormCollection = isLibraryPage ? 'library' : 'wishlist';
         
           multiEditorOverlay.style.display = "flex";
           loadCurrentMultiCreateEntry();
         }
         
         function updateMultiEditorHeader() {
           if (multiEditorTitle) {
             multiEditorTitle.textContent = (multiEditorMode === 'series')
               ? 'Multi-Create Volumes'
               : 'Multi-Select Editing';
           }
           if (multiEditorSaveAll) {
             multiEditorSaveAll.textContent = (multiEditorMode === 'series')
               ? 'Save All Volumes'
               : 'Save All Changes';
           }
           if (multiEditorAddVolume) {
             multiEditorAddVolume.style.display = (multiEditorMode === 'series')
               ? 'inline-block'
               : 'none';
           }
         }
         
         function loadCurrentMultiCreateEntry() {
           const item = multiCreateItems[multiCreateIndex];
           updateMultiEditorHeader();
         
           // Position info (common)
           multiEditorPosition.textContent = `Entry ${multiCreateIndex + 1} of ${multiCreateItems.length}`;
         
           if (multiEditorMode === 'series' && currentSeriesSuggestion) {
               // Series / volume mode
               const vol = multiCreateVolumes[multiCreateIndex];
               multiEditorSeriesLabel.textContent =
                   (currentSeriesSuggestion.displayName || currentSeriesSuggestion.baseName);
               multiEditorVolumeLabel.style.display = 'block';
               multiEditorVolumeLabel.textContent = `Volume ${vol}`;
           } else {
               // Multi-select edit mode
               multiEditorSeriesLabel.textContent = item.title || (
                   currentSectionKey === 'library'
                       ? 'Library Entry'
                       : 'Wishlist Entry'
               );
               multiEditorVolumeLabel.style.display = 'none';
           }
         
           // Common field binding
           multiEditorTitleInput.value     = item.title;
           multiEditorAuthorsInput.value   = item.authors;
           multiEditorPublisherInput.value = item.publisher;
           setDateInputValue(multiEditorDateInput, item.date);
           multiEditorIsbnInput.value      = item.isbn;
           multiEditorCoverInput.value     = item.cover;

           multiEditorCoverPreview.src =
               item.cover || "https://via.placeholder.com/150x220?text=No+Cover";
         
           // Show Amazon URL only for wishlist editing
           const isWishlist = (adminFormCollection === "wishlist" || currentSectionKey === 'wishlist');
           if (isWishlist) {
               multiEditorAmazonWrapper.style.display = "flex";
               multiEditorAmazonInput.value = item.amazonURL || "";
               multiEditorReadWrapper.style.display = "none";
               if (multiEditorDateReadWrapper) multiEditorDateReadWrapper.style.display = "none";
               if (multiEditorReadInput) multiEditorReadInput.checked = false;
               if (multiEditorDateReadInput) multiEditorDateReadInput.value = "";
           } else {
               multiEditorAmazonWrapper.style.display = "none";
               multiEditorReadWrapper.style.display = "flex";
               multiEditorReadInput.checked = !!item.read;
               if (multiEditorDateReadWrapper) {
                 multiEditorDateReadWrapper.style.display = item.read ? "flex" : "none";
               }
               if (multiEditorDateReadInput) {
                 setDateInputValue(multiEditorDateReadInput, item.read ? (item.dateRead || "") : "");
               }
           }
         }
         
         
         
         multiEditorPrev.onclick = () => {
           saveCurrentMultiCreateEntry();
           if (multiCreateIndex > 0) {
               multiCreateIndex--;
               loadCurrentMultiCreateEntry();
           }
         };
         
         multiEditorNext.onclick = () => {
           saveCurrentMultiCreateEntry();
           if (multiCreateIndex < multiCreateItems.length - 1) {
               multiCreateIndex++;
               loadCurrentMultiCreateEntry();
           }
         };
         
         function saveCurrentMultiCreateEntry() {
           const item = multiCreateItems[multiCreateIndex];
           item.title = multiEditorTitleInput.value.trim();
           item.authors = multiEditorAuthorsInput.value.trim();
           item.publisher = multiEditorPublisherInput.value.trim();
           item.date = multiEditorDateInput.value.trim();
           item.isbn = multiEditorIsbnInput.value.trim();
           item.cover = multiEditorCoverInput.value.trim();
           item.amazonURL = multiEditorAmazonInput.value.trim();
           if (multiEditorReadInput) {
             item.read = !!multiEditorReadInput.checked;
           }
           if (multiEditorDateReadInput) {
             const dr = multiEditorDateReadInput.value.trim();
             item.dateRead = /^\d{4}-\d{2}-\d{2}$/.test(dr) ? dr : "";
             if (item.read && !item.dateRead) {
               item.dateRead = new Date().toISOString().slice(0,10);
             }
             if (!item.read) {
               item.dateRead = "";
             }
           }
         }
         
         function openMultiCreateEditor(volumes) {
           const wrap = document.getElementById("multiCreateList");
           const panel = document.getElementById("multiCreatePanel");
           const addBtn = document.getElementById("multiCreateAddButton");
         
           wrap.innerHTML = "";
           panel.style.display = "block";
         
           // Show the + button
           addBtn.style.display = "block";
         
           const baseTitle = adminTitleInput.value.replace(/Vol\.\s*\d+/i, "").trim();
         
           function addVolumeRow(volNum) {
               const row = document.createElement("div");
               row.style = "display:flex; gap:8px; align-items:center;";
         
               row.innerHTML = `
                   <input type="text"
                       value="${baseTitle}, Vol. ${volNum}"
                       data-vol="${volNum}"
                       style="flex:1; padding:6px; background:#2b0f1d; border:1px solid #bb7f8f; color:#fff; border-radius:6px;">
               `;
         
               wrap.appendChild(row);
               row.scrollIntoView({ behavior: "smooth", block: "center" });
           }
         
           // Pre-generate suggested volumes
           volumes.forEach(v => addVolumeRow(v));
         
           // Add new volumes when + pressed
           addBtn.onclick = () => {
               const nextVol = prompt("Enter new volume number:");
         
               if (!nextVol || !/^\d+$/.test(nextVol)) {
                   alert("Please enter a valid number.");
                   return;
               }
         
               addVolumeRow(parseInt(nextVol, 10));
           };
         }
         
         
         
         // Helpers for wishlist countdown
         function parseWishlistDate(dateStr) {
           if (!dateStr) return null;
           const trimmed = ("" + dateStr).trim();
           if (!trimmed || /^unknown$/i.test(trimmed)) return null;
           if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
             const [y, m, d] = trimmed.split("-").map(Number);
             const localDate = new Date(y, m - 1, d);
             return isNaN(localDate) ? null : localDate;
           }
           const parsed = new Date(trimmed);
           return isNaN(parsed) ? null : parsed;
         }
         
         function parseYMD(dateStr) {
           if (!dateStr || !/^\d{4}-\d{2}-\d{2}$/.test(dateStr.trim())) return null;
           const [y, m, d] = dateStr.split('-').map(Number);
           const dt = new Date(y, m - 1, d);
           return isNaN(dt) ? null : dt;
         }
         
         function parseFlexibleDate(dateStr) {
           if (!dateStr) return null;
           const ymd = parseYMD(dateStr.trim());
           if (ymd) return ymd;
           const parsed = new Date(dateStr);
           return isNaN(parsed) ? null : parsed;
         }

         function formatDateDisplay(dt) {
           if (!dt) return '';
           return dt.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
         }
         
         function resolveReadDate(book) {
           if (!book || !book.Read) return null;
           const candidates = [book.DateRead, book.DatePurchased, book.Date];
           for (const c of candidates) {
             const dt = parseFlexibleDate(c);
             if (dt) return dt;
           }
           return null;
         }

         function computeTopCounts(list, key, topN = 3) {
           const counts = new Map();
           list.forEach(item => {
             const val = (item[key] || "").trim();
             if (!val || val.toLowerCase() === 'unknown') return;
             counts.set(val, (counts.get(val) || 0) + 1);
           });
           return Array.from(counts.entries())
             .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
             .slice(0, topN);
         }

         function pickMostCommonValue(books, key) {
           const counts = new Map();
           books.forEach(b => {
             const val = (b[key] || "").trim();
             if (!val || val.toLowerCase() === 'unknown') return;
             counts.set(val, (counts.get(val) || 0) + 1);
           });
           let bestVal = "";
           let bestCount = 0;
           counts.forEach((count, val) => {
             if (count > bestCount || (count === bestCount && val.localeCompare(bestVal) < 0)) {
               bestVal = val;
               bestCount = count;
             }
           });
           return bestVal;
         }

         function computeTopCountsBySeries(list, key, topN = 3) {
           const seriesMap = new Map();
           list.forEach(b => {
             const sKey = getSeriesKey(b) || (b.id || "");
             if (!seriesMap.has(sKey)) seriesMap.set(sKey, []);
             seriesMap.get(sKey).push(b);
           });

           const counts = new Map();
           seriesMap.forEach(books => {
             const val = pickMostCommonValue(books, key);
             if (!val) return;
             counts.set(val, (counts.get(val) || 0) + 1);
           });

           return Array.from(counts.entries())
             .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
             .slice(0, topN);
         }

         function renderTopList(el, items, emptyText) {
           if (!el) return;
           el.innerHTML = '';
           if (!items.length) {
             el.textContent = emptyText;
             return;
           }
           items.forEach(([name, count], idx) => {
             const row = document.createElement('div');
             row.className = 'stat-list-row';
             row.innerHTML = `
               <span class="stat-rank">${idx + 1}.</span>
               <span class="stat-name">${name}</span>
               <span class="stat-count">${count}</span>
             `;
             el.appendChild(row);
           });
         }

         function downloadBlob(content, filename, contentType) {
           const blob = (content instanceof Blob) ? content : new Blob([content], { type: contentType });
           const url = URL.createObjectURL(blob);
           const a = document.createElement('a');
           a.href = url;
           a.download = filename;
           document.body.appendChild(a);
           a.click();
           document.body.removeChild(a);
           URL.revokeObjectURL(url);
         }

         function exportToJSON() {
           const payload = {
             library: libraryBooks,
             wishlist: wishlistItems
           };
           downloadBlob(JSON.stringify(payload, null, 2), 'manga-library.json', 'application/json');
           addActivity('Exported library and wishlist to JSON');
         }

         function exportToCSV() {
           const headers = ['Collection','Title','Authors','Publisher','Date','ISBN','Read','DateRead','DatePurchased','MSRP','Cover','AmazonURL'];
           const rows = [headers.join(',')];
           const esc = (val) => {
             if (val === null || val === undefined) return '';
             const str = String(val);
             if (/[",\n]/.test(str)) return `"${str.replace(/"/g,'""')}"`;
             return str;
           };
           libraryBooks.forEach(b => {
             rows.push([
               'Library',
               esc(b.Title),
               esc(b.Authors),
               esc(b.Publisher),
               esc(b.Date),
               esc(b.ISBN),
               b.Read ? 'Yes' : 'No',
               esc(b.DateRead),
               esc(b.DatePurchased),
               esc(b.MSRP),
               esc(b.Cover),
               ''
             ].join(','));
           });
           wishlistItems.forEach(b => {
             rows.push([
               'Wishlist',
               esc(b.Title),
               esc(b.Authors),
               esc(b.Publisher),
               esc(b.Date),
               esc(b.ISBN),
               '',
               '',
               '',
               '',
               esc(b.Cover),
               esc(b.AmazonURL || '')
             ].join(','));
           });
           downloadBlob(rows.join('\n'), 'manga-library.csv', 'text/csv');
           addActivity('Exported library and wishlist to CSV');
         }

         async function exportCoversZip() {
           if (typeof JSZip === 'undefined') {
             alert('Export failed: zip library not loaded.');
             return;
           }
           const all = libraryBooks.concat(wishlistItems).filter(b => b.Cover);
           if (!all.length) {
             alert('No covers to export.');
             return;
           }
           if (exportCoversBtn) {
             exportCoversBtn.disabled = true;
             exportCoversBtn.textContent = 'Preparing zip...';
           }
           const zip = new JSZip();
           const tasks = all.map(async (b, idx) => {
             try {
               const resp = await fetch(b.Cover);
               if (!resp.ok) return;
               const blob = await resp.blob();
               const safeName = (b.Title || `cover-${idx+1}`).replace(/[^a-z0-9]+/gi,'-').replace(/^-+|-+$/g,'') || `cover-${idx+1}`;
               const ext = blob.type && blob.type.includes('png') ? 'png' : 'jpg';
               zip.file(`${safeName}.${ext}`, blob);
             } catch (e) {
               console.warn('Cover fetch failed for', b.Title, e);
             }
           });
           await Promise.all(tasks);
           const blob = await zip.generateAsync({ type: 'blob' });
           downloadBlob(blob, 'manga-covers.zip', 'application/zip');
           addActivity('Exported covers zip');
           if (exportCoversBtn) {
             exportCoversBtn.disabled = false;
             exportCoversBtn.textContent = 'Export Covers as Zip';
           }
         }
         
         function findNextWishlistRelease() {
           if (!wishlistItems || !wishlistItems.length) return null;
           const now = new Date();
           let best = null;
           wishlistItems.forEach(item => {
             const releaseDate = parseWishlistDate(item.Date);
             if (!releaseDate) return;
             if (releaseDate.getTime() <= now.getTime()) return;
             if (!best || releaseDate.getTime() < best.date.getTime()) {
               best = { item, date: releaseDate };
             }
           });
           return best;
         }

         function getFutureWishlistReleases() {
           const today = new Date();
           today.setHours(0,0,0,0);
           return wishlistItems
             .map(item => {
               const dt = parseWishlistDate(item.Date);
               return dt ? { item, date: dt } : null;
             })
             .filter(Boolean)
             .filter(entry => entry.date.getTime() >= today.getTime());
         }

         function renderReleaseCalendar() {
           if (!releaseCalendar || !releaseCalendarLabel) return;

           // Normalize cursor to first of month
           calendarMonthCursor = new Date(calendarMonthCursor.getFullYear(), calendarMonthCursor.getMonth(), 1);
           const monthStart = calendarMonthCursor;
           const monthName = monthStart.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
           releaseCalendarLabel.textContent = `Wishlist Releases  ${monthName}`;

           const today = new Date();
           today.setHours(0,0,0,0);

           const monthReleases = getFutureWishlistReleases().filter(r =>
             r.date.getFullYear() === monthStart.getFullYear() &&
             r.date.getMonth() === monthStart.getMonth()
           );

           if (releaseCalendar) releaseCalendar.innerHTML = '';
           const daysInMonth = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0).getDate();
           const firstWeekday = monthStart.getDay();

           for (let i = 0; i < firstWeekday; i++) {
             const pad = document.createElement('div');
             pad.className = 'calendar-day pad';
             releaseCalendar.appendChild(pad);
           }

           let placedReleaseCount = 0;

           for (let day = 1; day <= daysInMonth; day++) {
             const cell = document.createElement('div');
             cell.className = 'calendar-day';
             const num = document.createElement('div');
             num.className = 'day-num';
             num.textContent = day;
             cell.appendChild(num);

             const releasesForDay = monthReleases.filter(r => r.date.getDate() === day);
             placedReleaseCount += releasesForDay.length;

             releasesForDay.slice(0, 3).forEach(r => {
               const chip = document.createElement('div');
               chip.className = 'calendar-release';
               chip.textContent = r.item.Title || 'Untitled';
               cell.appendChild(chip);
             });

             if (releasesForDay.length > 3) {
               const more = document.createElement('div');
               more.className = 'calendar-release';
               more.textContent = `+${releasesForDay.length - 3} more`;
               cell.appendChild(more);
             }

             releaseCalendar.appendChild(cell);
           }

           if (releaseCalendarEmpty) {
             releaseCalendarEmpty.style.display = placedReleaseCount ? 'none' : 'block';
           }
         }

         function shiftCalendarMonth(delta) {
           const d = new Date(calendarMonthCursor);
           d.setMonth(d.getMonth() + delta, 1);
           calendarMonthCursor = d;
           renderReleaseCalendar();
         }
         
         function stopWishlistCountdown() {
           if (wishlistCountdownInterval) {
             clearInterval(wishlistCountdownInterval);
             wishlistCountdownInterval = null;
           }
         }
         
         function updateWishlistCountdown() {
           stopWishlistCountdown();
           if (!wishlistCountdownEl || !wishlistCountdownTitle || !wishlistCountdownTimer) return;
 
           const next = findNextWishlistRelease();
           nextWishlistRelease = next;
 
           if (!next) {
             wishlistCountdownEl.style.display = 'none';
             wishlistCountdownTitle.textContent = '';
             wishlistCountdownTimer.textContent = '';
             if (statNextRelease) statNextRelease.textContent = 'None scheduled';
             if (statNextCountdown) statNextCountdown.textContent = '';
             return;
           }
 
           const target = next.date;
           wishlistCountdownTitle.textContent = `Next Release: ${next.item.Title || 'Unknown'}`;
           wishlistCountdownEl.style.display = 'block';
           if (wishlistCountdownDate) wishlistCountdownDate.textContent = formatDateDisplay(target);
           if (statNextRelease) statNextRelease.textContent = next.item.Title || 'Unknown';
           if (statNextReleaseDate) statNextReleaseDate.textContent = formatDateDisplay(target);

           const tick = () => {
             const now = new Date();
             let diff = target.getTime() - now.getTime();
             if (diff <= 0) {
               updateWishlistCountdown();
               return;
             }
             const dayMs = 86400000;
             const hourMs = 3600000;
             const minuteMs = 60000;
         
             const days = Math.floor(diff / dayMs);
             diff -= days * dayMs;
             const hours = Math.floor(diff / hourMs);
             diff -= hours * hourMs;
             const minutes = Math.floor(diff / minuteMs);
             diff -= minutes * minuteMs;
             const seconds = Math.floor(diff / 1000);
 
             wishlistCountdownTimer.textContent =
               `${days}d ${String(hours).padStart(2, '0')}h ${String(minutes).padStart(2, '0')}m ${String(seconds).padStart(2, '0')}s`;
             if (statNextCountdown) {
               statNextCountdown.textContent =
                 `${days}d ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
             }
           };
 
           tick();
           wishlistCountdownInterval = setInterval(tick, 1000);
         }
         
         function updateDashboardStats() {
           // Skip if core stat nodes are missing; next release is optional
           if (!statTotalLibrary || !statRead || !statUnread || !statWishlist) return;
           const currentYear = new Date().getFullYear();
           const totalLib = libraryBooks.length;
           const readCount = libraryBooks.filter(b => b.Read).length;
           const unreadCount = totalLib - readCount;
           const wishCount = wishlistItems.length;
           statTotalLibrary.textContent = totalLib;
           statRead.textContent = readCount;
           statUnread.textContent = unreadCount;
           statWishlist.textContent = wishCount;
           const readPct = totalLib ? Math.round((readCount / totalLib) * 100) : 0;
           const animatePie = (node, pct, label) => {
             if (!node) return;
             node.style.setProperty('--pct', 0);
             requestAnimationFrame(() => {
               requestAnimationFrame(() => node.style.setProperty('--pct', pct));
             });
             node.dataset.label = label;
           };
           animatePie(pieRead, readPct, `${readCount} read / ${unreadCount} unread (${readPct}%)`);
           if (statReadPct) statReadPct.textContent = `${readPct}%`;
           
           const totalAll = totalLib + wishCount;
           const libPct = totalAll ? Math.round((totalLib / totalAll) * 100) : 0;
           animatePie(pieCollection, libPct, `${totalLib} in library / ${wishCount} in wishlist (${libPct}% library)`);
           if (statCollectionPct) statCollectionPct.textContent = `${libPct}%`;
           if (statLibShare) statLibShare.textContent = totalLib;
           if (statWishShare) statWishShare.textContent = wishCount;
           const totalMsrp = libraryBooks.reduce((sum, b) => {
             const v = (b.MSRP !== undefined && b.MSRP !== null && b.MSRP !== "") ? parseFloat(b.MSRP) : NaN;
             return Number.isFinite(v) ? sum + v : sum;
           }, 0);
           if (statCollectionValue) {
             statCollectionValue.textContent = `$${totalMsrp.toFixed(2)}`;
           }
           // Top lists
           renderTopList(statTopDemographics, computeTopCountsBySeries(libraryBooks, 'Demographic'), 'No demographics yet');
           renderTopList(statTopPublishers, computeTopCountsBySeries(libraryBooks, 'Publisher'), 'No publishers yet');
           renderTopList(statTopGenres, computeTopCountsBySeries(libraryBooks, 'Genre'), 'No genres yet');
           // Current year read count
           const readThisYear = libraryBooks.filter(b => {
             const dt = resolveReadDate(b);
             return dt && dt.getFullYear() === currentYear;
           }).length;
           if (statCurrentYearTitle) statCurrentYearTitle.textContent = `Current Reads ${currentYear}`;
           if (statCurrentYearValue) statCurrentYearValue.textContent = readThisYear;
           if (statCurrentYearSub) statCurrentYearSub.textContent = readThisYear ? 'Year-to-date' : 'No reads yet';
           
           // Average time from purchase to read
           const diffs = [];
           libraryBooks.forEach(b => {
             if (!b.Read || !b.DatePurchased || !b.DateRead) return;
             const dp = parseFlexibleDate(b.DatePurchased);
             const dr = parseFlexibleDate(b.DateRead);
             if (!dp || !dr) return;
             const diffDays = Math.max(0, Math.round((dr.getTime() - dp.getTime()) / 86400000));
             diffs.push(diffDays);
           });
           if (statAvgReadTime) {
             if (diffs.length) {
               const avg = diffs.reduce((a, b) => a + b, 0) / diffs.length;
               statAvgReadTime.textContent = `${avg.toFixed(1)} days`;
             } else {
               statAvgReadTime.textContent = '--';
             }
           }
           if (statAvgReadTimeSub) {
             statAvgReadTimeSub.textContent = diffs.length
               ? `${diffs.length} book${diffs.length === 1 ? '' : 's'} counted`
               : 'Need purchase + read dates';
           }
           
           // Reads per month chart (current year)
           const monthCounts = Array(12).fill(0);
           libraryBooks.forEach(b => {
             const dt = resolveReadDate(b);
             if (!dt || dt.getFullYear() !== currentYear) return;
             monthCounts[dt.getMonth()] += 1;
           });
           if (statMonthlyYear) statMonthlyYear.textContent = `(${currentYear})`;
           if (statMonthlyLine) {
             statMonthlyLine.innerHTML = '';
             const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
             const maxVal = Math.max(...monthCounts, 1);
             const svgNS = "http://www.w3.org/2000/svg";
             const svg = document.createElementNS(svgNS, 'svg');
             // Roomy viewBox so month labels have space without stretching
             const viewWidth = 220;
             const viewHeight = 90;
             const leftPad = 12;
             const rightPad = 12;
             const topPad = 8;
             const bottomPad = 22; // space for angled month labels
             const usableWidth = viewWidth - leftPad - rightPad;
             const usableHeight = viewHeight - topPad - bottomPad;
             svg.setAttribute('viewBox', `0 0 ${viewWidth} ${viewHeight}`);
             svg.setAttribute('preserveAspectRatio', 'xMidYMid meet'); // keep proportions while filling space
             // grid lines
             for (let i = 0; i <= 4; i++) {
               const y = topPad + (usableHeight / 4) * i;
               const line = document.createElementNS(svgNS, 'line');
               line.setAttribute('x1', `${leftPad}`);
               line.setAttribute('x2', `${viewWidth - rightPad}`);
               line.setAttribute('y1', `${y}`);
               line.setAttribute('y2', `${y}`);
               line.setAttribute('class', 'line-grid');
               svg.appendChild(line);
             }
             // points and path
             const points = monthCounts.map((count, idx) => {
               const x = leftPad + (idx / 11) * usableWidth;
               const y = topPad + (maxVal === 0 ? usableHeight : (1 - (count / maxVal)) * usableHeight);
               return { x, y, count, label: monthNames[idx] };
             });
             const poly = document.createElementNS(svgNS, 'polyline');
             poly.setAttribute('points', points.map(p => `${p.x},${p.y}`).join(' '));
             poly.setAttribute('class', 'line-path');
             svg.appendChild(poly);
             points.forEach(p => {
               const c = document.createElementNS(svgNS, 'circle');
               c.setAttribute('cx', `${p.x}`);
               c.setAttribute('cy', `${p.y}`);
               c.setAttribute('r', '1.8');
               c.setAttribute('class', 'line-point');
               svg.appendChild(c);
               if (p.count > 0) {
               const tv = document.createElementNS(svgNS, 'text');
               tv.setAttribute('x', `${p.x}`);
               tv.setAttribute('y', `${p.y - 10}`);
               tv.setAttribute('class', 'line-value');
               tv.textContent = p.count;
               svg.appendChild(tv);
               }
               const tl = document.createElementNS(svgNS, 'text');
               const labelY = viewHeight - 5;
               tl.setAttribute('x', `${p.x}`);
               tl.setAttribute('y', `${labelY}`);
               tl.setAttribute('class', 'line-label');
               tl.setAttribute('transform', `rotate(-20 ${p.x} ${labelY})`);
               tl.textContent = p.label;
               svg.appendChild(tl);
             });
             statMonthlyLine.appendChild(svg);
           }
           // Day of week (lifetime)
           if (statDayOfWeekBars) {
             statDayOfWeekBars.innerHTML = '';
             const dowCounts = Array(7).fill(0);
             libraryBooks.forEach(b => {
               const dt = resolveReadDate(b);
               if (!dt) return;
               dowCounts[dt.getDay()] += 1;
             });
             const dowNames = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
             const maxDow = Math.max(...dowCounts, 1);
             dowCounts.forEach((count, idx) => {
               const bar = document.createElement('div');
               bar.className = 'bar';
               const value = document.createElement('div');
               value.className = 'bar-value';
               value.textContent = count;
               const fill = document.createElement('div');
               fill.className = 'bar-fill';
               const pct = count ? Math.max(8, (count / maxDow) * 100) : 4;
               fill.style.height = `${pct}%`;
               const label = document.createElement('div');
               label.className = 'bar-label';
               label.textContent = dowNames[idx];
               bar.appendChild(value);
               bar.appendChild(fill);
               bar.appendChild(label);
               statDayOfWeekBars.appendChild(bar);
             });
           }
           if (!nextWishlistRelease) {
             updateWishlistCountdown();
           }
           if (statNextRelease) {
             if (nextWishlistRelease && nextWishlistRelease.item) {
               statNextRelease.textContent = nextWishlistRelease.item.Title || 'Unknown';
               if (statNextReleaseDate) {
                 statNextReleaseDate.textContent = formatDateDisplay(nextWishlistRelease.date);
               }
             } else {
               statNextRelease.textContent = 'None scheduled';
               if (statNextReleaseDate) statNextReleaseDate.textContent = '';
             }
           }
         }
         
         // ===== LOAD LIBRARY FROM FIRESTORE =====
         async function loadLibraryFromFirestore() {
           const snap = await getDocs(collection(db, "library"));
           libraryBooks = [];
           snap.forEach(docSnap => {
             const data = docSnap.data();
           libraryBooks.push({
             id: docSnap.id,
             Title: data.title || "",
             Authors: data.authors || "Unknown",
             Publisher: data.publisher || "Unknown",
             Demographic: data.demographic || "",
             Genre: data.genre || "",
             SubGenre: data.subGenre || "",
             Date: data.date || "Unknown",
             Cover: data.cover || "",
             ISBN: data.isbn || "",
             DateRead: data.dateRead || "",
             DatePurchased: data.datePurchased || "",
             MSRP: (data.msrp !== undefined && data.msrp !== null) ? data.msrp : "",
             Read: !!data.read,
             kind: "library"
           });
         });
         
           // Sort
           libraryBooks.sort((a, b) => {
             const aP = parseTitleForSort(a.Title);
             const bP = parseTitleForSort(b.Title);
             const cmp = aP.name.localeCompare(bP.name);
             return cmp !== 0 ? cmp : (aP.vol - bP.vol);
           });
         
           // Render
           bookGrid.innerHTML = "";
           let readCount = 0;
           libraryBooks.forEach(b => {
             if (b.Read) readCount++;
         
             const card = document.createElement('div');
             card.className = 'card' + (b.Read ? ' read' : '');
             card.dataset.id = b.id;
             card.dataset.kind = 'library';
             const searchable = [
               b.Title || '',
               b.Authors || '',
               b.Publisher || '',
               b.ISBN || '',
               b.Date || ''
             ].join(' ').toLowerCase();
             card.dataset.search = searchable;
             card.innerHTML = `
                 <img src="${b.Cover || 'https://via.placeholder.com/150x220?text=No+Cover'}" alt="Cover">
                 <div class="title">${b.Title || ''}</div>
                 <div class="meta">${
                   (b.Authors && b.Authors!=='Unknown' ? b.Authors + '<br>' : '') +
                   (b.Publisher && b.Publisher!=='Unknown' ? b.Publisher + '<br>' : '') +
                   (b.Date && b.Date!=='Unknown' ? b.Date + '<br>' : '') +
                   (b.Read && b.DateRead ? ('Read on ' + formatDateMMDDYYYY(b.DateRead) + '<br>') : '')
                 }</div>
                 <div class="isbn">${b.ISBN || ''}</div>
             `;
         
             card.addEventListener('click', (e) => {
               if (multiSelectActive && isAdmin && currentSectionKey === 'library') {
                 e.preventDefault();
                 e.stopPropagation();
                 toggleCardSelection(card, b.id);
               } else {
                 showPopup(b);
               }
             });
         
             bookGrid.appendChild(card);
           });
         
           totalTop.textContent    = `Total Books: ${libraryBooks.length}`;
           totalBottom.textContent = `Total Books: ${libraryBooks.length}`;
           readTop.textContent     = `Books Read: ${readCount}`;
           readBottom.textContent  = `Books Read: ${readCount}`;
        
           updateCounters();
           updateDashboardStats();
           renderDashboardLibraryList();
           if (dashSelectedBookId) {
             openDashboardDetail(dashSelectedBookId);
           } else if (dashSelectedSeriesKey) {
             openSeriesDetail(dashSelectedSeriesKey);
           }
         } // <-- properly close loadLibraryFromFirestore
         
         
         // ===== LOAD WISHLIST FROM FIRESTORE =====
         async function loadWishlistFromFirestore() {
           const snap = await getDocs(collection(db, "wishlist"));
           wishlistItems = [];
           snap.forEach(docSnap => {
             const data = docSnap.data();
             wishlistItems.push({
               id: docSnap.id,
               Title: data.title || "",
               Authors: data.authors || "Unknown",
               Publisher: data.publisher || "Unknown",
               Date: data.date || "Unknown",
               Cover: data.cover || "",
               ISBN: data.isbn || "",
               AmazonURL: data.amazonURL || "",
               kind: "wishlist"
             });
           });
         
           // same sorting as library
           wishlistItems.sort((a, b) => {
             const aP = parseTitleForSort(a.Title);
             const bP = parseTitleForSort(b.Title);
             const cmp = aP.name.localeCompare(bP.name);
             return cmp !== 0 ? cmp : (aP.vol - bP.vol);
           });
         
           wishlistGrid.innerHTML = "";
           wishlistItems.forEach(b => {
             const card = document.createElement('div');
             card.className = 'card';
             card.dataset.id = b.id;
             card.dataset.kind = 'wishlist';
             const searchable = [
               b.Title || '',
               b.Authors || '',
               b.Publisher || '',
               b.ISBN || '',
               b.Date || ''
             ].join(' ').toLowerCase();
             card.dataset.search = searchable;
             card.innerHTML = `
               <img src="${b.Cover || 'https://via.placeholder.com/150x220?text=No+Cover'}" alt="Cover">
               <div class="title">${b.Title || ''}</div>
               <div class="meta">${
                 (b.Authors && b.Authors!=='Unknown' ? b.Authors + '<br>' : '') +
                 (b.Publisher && b.Publisher!=='Unknown' ? b.Publisher + '<br>' : '') +
                 (b.Date && b.Date!=='Unknown' ? b.Date + '<br>' : '')
               }</div>
             `;
         
             card.addEventListener('click', (e) => {
               if (multiSelectActive && isAdmin && currentSectionKey === 'wishlist') {
                 e.preventDefault();
                 e.stopPropagation();
                 toggleCardSelection(card, b.id);
               } else {
                 showPopup(b);
               }
             });
         
             wishlistGrid.appendChild(card);
         });
        
         updateWishlistCountdown();
         updateDashboardStats();
         renderReleaseCalendar();
         searchWishlist();
        }
         
         // ===== RELOAD BOTH =====
         async function reloadAll() {
           await loadLibraryFromFirestore();
           await loadWishlistFromFirestore();
         }
         
         
         // ===== LIBRARY FILTER & COUNTERS =====
         let searchLibTimeout = null;
         let searchWishTimeout = null;

         function searchLibrary() {
           const input = searchInput.value.toLowerCase();
           const cards = bookGrid.getElementsByClassName('card');
         
           for (const card of cards) {
             const isRead = card.classList.contains('read');
             const searchable = card.dataset.search || card.innerText.toLowerCase();
         
             let visibleBySort = false;
             if (readClickState === 0) visibleBySort = true;
             else if (readClickState === 1 && isRead) visibleBySort = true;
             else if (readClickState === 2 && !isRead) visibleBySort = true;
         
             const visibleBySearch = input === '' || searchable.includes(input);
         
             card.style.display = (visibleBySort && visibleBySearch) ? '' : 'none';
           }
         
           updateCounters();
         }

         function searchWishlist() {
           const query = wishlistSearchInput ? wishlistSearchInput.value.toLowerCase() : '';
           const cards = wishlistGrid ? wishlistGrid.getElementsByClassName('card') : [];
          
           for (const card of cards) {
             const searchable = card.dataset.search || card.innerText.toLowerCase();
             const visibleBySearch = query === '' || searchable.includes(query);
             card.style.display = visibleBySearch ? '' : 'none';
           }
          
           updateWishlistCounter();
         }

         function scheduleSearchLibrary() {
           if (searchLibTimeout) clearTimeout(searchLibTimeout);
           searchLibTimeout = setTimeout(searchLibrary, 80);
         }

         function scheduleSearchWishlist() {
           if (searchWishTimeout) clearTimeout(searchWishTimeout);
           searchWishTimeout = setTimeout(searchWishlist, 80);
         }
         
         function updateWishlistCounter() {
           if (!wishlistGrid || !wishlistCount) return;
           const cards = Array.from(wishlistGrid.querySelectorAll('.card'));
           const visible = cards.filter(card => card.style.display !== 'none').length;
           const total = wishlistItems.length;
           wishlistCount.textContent = (wishlistSearchInput && wishlistSearchInput.value.trim())
             ? `Wishlist Items: ${visible} / ${total}`
             : `Wishlist Items: ${total}`;
         }
         
         function updateCounters() {
           const cards = Array.from(bookGrid.querySelectorAll('.card'));
           if (!readTop || !readBottom) return;
         
           if (readClickState === 0) {
             const totalRead = cards.filter(card => card.classList.contains('read')).length;
             readTop.innerText = `Books Read: ${totalRead}`;
             readBottom.innerText = `Books Read: ${totalRead}`;
             readTop.style.color = '';
             readBottom.style.color = '';
           } else {
             let readCount = 0;
             let unreadCount = 0;
             for (const card of cards) {
               if (card.style.display !== 'none') {
                 if (card.classList.contains('read')) readCount++;
                 else unreadCount++;
               }
             }
             if (readClickState === 1) {
               readTop.innerText = `Books Read: ${readCount}`;
               readBottom.innerText = `Books Read: ${readCount}`;
               readTop.style.color = '#32CD32';
               readBottom.style.color = '#32CD32';
             } else if (readClickState === 2) {
               readTop.innerText = `Books Not Read: ${unreadCount}`;
               readBottom.innerText = `Books Not Read: ${unreadCount}`;
               readTop.style.color = '#FF5555';
               readBottom.style.color = '#FF5555';
             }
           }
         }
         
         function toggleReadFilter() {
           readClickState = (readClickState + 1) % 3;
           searchLibrary();
         }
         
         readTop.addEventListener('click', toggleReadFilter);
         readBottom.addEventListener('click', toggleReadFilter);
         if (searchInput) {
           searchInput.addEventListener('input', scheduleSearchLibrary);
         }
         if (wishlistSearchInput) {
           wishlistSearchInput.addEventListener('input', scheduleSearchWishlist);
         }
         
         // ===== POPUP =====
         function classifyStore(url) {
           try {
             const parsed = new URL(url);
             const host = parsed.hostname.toLowerCase();
             if (host.includes('amazon.') || host === 'amzn.to') {
               return { store: 'amazon', label: 'Amazon', icon: 'a' };
             }
             if (host.includes('crunchyroll')) {
               return { store: 'crunchyroll', label: 'Crunchyroll', icon: 'C' };
             }
             return { store: 'generic', label: host.replace(/^www\./, '') || 'Store', icon: '' };
           } catch (e) {
             return { store: 'generic', label: 'Store', icon: '' };
           }
         }

         function showPopup(book) {
           currentPopupBook = book;
           popupOverlay.style.display = 'flex';
         
           if (book.kind === "library" && (book.Read === true || book.Read === "true")) {
             popupContent.classList.add('read');
           } else {
             popupContent.classList.remove('read');
           }
           if (popupEdit) {
             popupEdit.onclick = () => {
               if (!currentPopupBook) return;
               openAdminForm({
                 mode: "edit",
                 collection: currentPopupBook.kind,
                 book: currentPopupBook
               });
             };
           }
         
         
           popupImage.src = book.Cover || 'https://via.placeholder.com/150x220?text=No+Cover';
           popupTitle.innerHTML = book.Title || '';
           let meta = '';
           if (book.Authors && book.Authors !== 'Unknown') meta += book.Authors + '<br>';
           if (book.Publisher && book.Publisher !== 'Unknown') meta += book.Publisher + '<br>';
           if (book.Date && book.Date !== 'Unknown') meta += book.Date + '<br>';
           popupMeta.innerHTML = meta;
           popupISBN.innerHTML = book.ISBN || '';

           if (book.kind === "library" && (book.Read === true || book.Read === "true")) {
             const dr = book.DateRead ? ` (on ${formatDateMMDDYYYY(book.DateRead)})` : '';
             popupMeta.innerHTML += `<br><span style="color:#6fcf97;"> Read${dr}</span>`;
           }
         
           if (book.AmazonURL) {
              const info = classifyStore(book.AmazonURL);
              popupBuy.className = "buy-button";
              popupBuy.classList.add(`buy-${info.store}`);
              popupBuy.style.display = "inline-flex";
              popupBuy.onclick = () => window.open(book.AmazonURL, '_blank');

              // Inline logos so they NEVER fail
              const amazonLogo = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 182'><path fill='%23FF9900' d='M77 0 ...'/></svg>";
              const crunchyLogo = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><path fill='%23F47521' d='M256 0c141.4 ...'/></svg>";

              let logoFile = (info.store === "amazon") ? amazonLogo :
                            (info.store === "crunchyroll") ? crunchyLogo :
                            "";

              document.getElementById("popupBuyLogo").src = logoFile;
              document.getElementById("popupBuyText").textContent = `Buy from ${info.label}`;
           } else {
             popupBuy.style.display = 'none';
             popupBuy.onclick = null;
           }
         
           // Admin controls
           if (isAdmin) {
             popupAdmin.style.display = 'flex';
             if (book.kind === "library") {
               popupToggleRead.style.display = 'inline-block';
             } else {
               popupToggleRead.style.display = 'none';
             }
           } else {
             popupAdmin.style.display = 'none';
           }
         }
         
         popupClose.addEventListener('click', () => {
           popupOverlay.style.display = 'none';
         });
         popupOverlay.addEventListener('click', (e) => {
           if (e.target === popupOverlay) {
             popupOverlay.style.display = 'none';
           }
         });
         
         // ===== ADMIN ACTIONS (popup) =====
         async function adminToggleRead() {
           if (!currentPopupBook || currentPopupBook.kind !== "library") return;
           const newVal = !currentPopupBook.Read;
           try {
             const payload = { read: newVal };
             payload.dateRead = newVal ? new Date().toISOString().slice(0,10) : "";
             await updateDoc(doc(db, "library", currentPopupBook.id), payload);
             await loadLibraryFromFirestore();
             // keep popup open but refresh its state
             const updated = libraryBooks.find(b => b.id === currentPopupBook.id);
             if (updated) showPopup(updated);
             addActivity(`${newVal ? 'Marked' : 'Unmarked'} "${currentPopupBook.Title || 'Untitled'}" as read`);
           } catch (err) {
             console.error(err);
             alert("Failed to update read status.");
           }
         }
         
         async function adminDeleteCurrent() {
           if (!currentPopupBook) return;
           const colName = currentPopupBook.kind === "wishlist" ? "wishlist" : "library";
           if (!confirm(`Delete this item from ${colName}?`)) return;
           try {
             await deleteDoc(doc(db, colName, currentPopupBook.id));
             popupOverlay.style.display = 'none';
             if (colName === "wishlist") {
               await loadWishlistFromFirestore();
             } else {
               await loadLibraryFromFirestore();
             }
             addActivity(`Deleted "${currentPopupBook.Title || 'Untitled'}" from ${colName}`);
           } catch (err) {
             console.error(err);
             alert("Failed to delete item.");
           }
         }
         
         popupToggleRead.addEventListener('click', adminToggleRead);
         popupDelete.addEventListener('click', adminDeleteCurrent);
         
         if (adminAddLibrary) {
           adminAddLibrary.addEventListener('click', () => {
             openAdminForm({ mode: "add", collection: "library" });
           });
         }
         if (adminAddWishlist) {
           adminAddWishlist.addEventListener('click', () => {
             openAdminForm({ mode: "add", collection: "wishlist" });
           });
         }
         if (adminMultiSelect) {
           adminMultiSelect.addEventListener('click', () => {
             if (!isAdmin) return;
             multiSelectActive = !multiSelectActive;
         
             if (!multiSelectActive) {
               exitMultiSelectMode();
             } else {
               // entering multi-select: clear previous selections & highlight
               multiSelectedIds.clear();
               document.querySelectorAll('.card').forEach(card => {
                 card.classList.remove('multi-selected');
               });
               updateMultiSelectUI();
             }
           });
         }
         
         
         async function applyMultiSelectAction(action) {
           const ids = Array.from(multiSelectedIds);
           if (!ids.length) {
             alert('Select at least one item first.');
             return;
           }
         
           const isLibraryPage = (currentSectionKey === 'library');
         
           try {
             if (action === 'move') {
               if (isLibraryPage) {
                 if (!confirm(`Move ${ids.length} item(s) to Wishlist?`)) return;
                 for (const id of ids) {
                   const b = libraryBooks.find(x => x.id === id);
                   if (!b) continue;
                   const payload = {
                     title: b.Title,
                     authors: b.Authors,
                     publisher: b.Publisher,
                     date: b.Date,
                     isbn: b.ISBN,
                     cover: b.Cover,
                     amazonURL: b.AmazonURL || ''
                   };
                   await addDoc(collection(db, "wishlist"), payload);
                   await deleteDoc(doc(db, "library", id));
                 }
               } else {
                 if (!confirm(`Move ${ids.length} item(s) to Library?`)) return;
                 for (const id of ids) {
                   const b = wishlistItems.find(x => x.id === id);
                   if (!b) continue;
                   const payload = {
                     title: b.Title,
                     authors: b.Authors,
                     publisher: b.Publisher,
                     date: b.Date,
                     isbn: b.ISBN,
                     cover: b.Cover,
                     read: false
                   };
                   await addDoc(collection(db, "library"), payload);
                   await deleteDoc(doc(db, "wishlist", id));
                 }
               }
            } else if (action === 'markRead' && isLibraryPage) {
              for (const id of ids) {
                await updateDoc(doc(db, "library", id), { read: true, dateRead: new Date().toISOString().slice(0,10) });
              }
            } else if (action === 'markUnread' && isLibraryPage) {
              for (const id of ids) {
                await updateDoc(doc(db, "library", id), { read: false, dateRead: "" });
              }
            } else if (action === 'delete') {
               const colName = isLibraryPage ? "library" : "wishlist";
               if (!confirm(`Delete ${ids.length} item(s) from ${isLibraryPage ? 'Library' : 'Wishlist'}?`)) return;
               for (const id of ids) {
                 await deleteDoc(doc(db, colName, id));
               }
             }
         
             if (action === 'move') {
               await reloadAll(); // both collections changed
             } else if (isLibraryPage) {
               await loadLibraryFromFirestore();
             } else {
               await loadWishlistFromFirestore();
             }
             const actionLabel = action === 'move'
               ? `Moved ${ids.length} item(s) ${isLibraryPage ? 'to wishlist' : 'to library'}`
               : action === 'markRead'
                 ? `Marked ${ids.length} item(s) as read`
                 : action === 'markUnread'
                   ? `Marked ${ids.length} item(s) as unread`
                   : action === 'delete'
                     ? `Deleted ${ids.length} item(s) from ${isLibraryPage ? 'library' : 'wishlist'}`
                     : `Updated ${ids.length} item(s)`;
             addActivity(actionLabel);
             exitMultiSelectMode();
           } catch (err) {
             console.error('Multi-select action error:', err);
             alert('Action failed. Check console for details.');
           }
         }
         
         // Hook buttons
         if (multiSelectMove) {
           multiSelectMove.addEventListener('click', () => applyMultiSelectAction('move'));
         }
         if (multiSelectMarkRead) {
           multiSelectMarkRead.addEventListener('click', () => applyMultiSelectAction('markRead'));
         }
         if (multiSelectMarkUnread) {
           multiSelectMarkUnread.addEventListener('click', () => applyMultiSelectAction('markUnread'));
         }
         if (multiSelectDelete) {
           multiSelectDelete.addEventListener('click', () => applyMultiSelectAction('delete'));
         }
         if (multiSelectCancel) {
           multiSelectCancel.addEventListener('click', () => exitMultiSelectMode());
         }
         if (multiSelectEdit) {
           multiSelectEdit.addEventListener('click', () => {
             if (!isAdmin) return;
             openMultiEditForSelection();
           });
         }
         
         // ===== AUTH =====
         loginBtn.addEventListener('click', () => {
           openAuthModal('signin');
         });
         
         logoutBtn.addEventListener('click', async () => {
           try {
             await signOut(auth);
           } catch (err) {
             console.error(err);
             alert("Logout failed: " + err.message);
           }
         });
         
        function updateAdminUI() {
          if (menuDashboard) {
            menuDashboard.style.display = isAdmin ? 'block' : 'none';
          }
           if (isAdmin) {
             adminBar.style.display = "block";
           } else {
             adminBar.style.display = "none";
           }
         }
         
         
         onAuthStateChanged(auth, async (user) => {
           if (user) {
             if (authSection) authSection.style.display = "block";
             authStatus.textContent = `Signed in as ${user.email}`;
             loginBtn.style.display = 'none';
             logoutBtn.style.display = 'inline-block';
         
             // Check Firestore for admin flag
             let adminFlag = false;
             try {
               const userRef = doc(db, "users", user.uid);
               const userSnap = await getDoc(userRef);
               if (userSnap.exists()) {
                 const data = userSnap.data();
                 adminFlag = !!data.admin;
               } else if (user.email === ADMIN_EMAIL) {
                 // Fallback so you don't lock yourself out:
                 adminFlag = true;
               }
             } catch (err) {
               console.error("Error checking admin flag", err);
             }
         
             isAdmin = adminFlag;
             updateAdminUI();
             closeAuthModal();
           } else {
             if (authSection) authSection.style.display = "none";
             authStatus.textContent = "Not signed in";
             loginBtn.style.display = 'inline-block';
             logoutBtn.style.display = 'none';
             isAdmin = false;
             updateAdminUI();
           }
         });
         
         
         // ===== BACK TO TOP =====
         window.addEventListener('scroll', () => {
           if (window.scrollY > 250) {
             backToTopBtn.classList.add('show');
           } else {
             backToTopBtn.classList.remove('show');
           }
         });
         backToTopBtn.addEventListener('click', () => {
           window.scrollTo({ top: 0, left: 0, behavior: 'smooth' });
         });
         
         // ===== INITIAL LOAD =====
         renderActivityLog();
         reloadAll();
         
           function resetAdminForm() {
               adminTitleInput.value     = "";
               adminAuthorsInput.value   = "";
               adminPublisherInput.value = "";
              setDateInputValue(adminDateInput, "");
              adminIsbnInput.value      = "";
              adminCoverInput.value     = "";
              adminAmazonInput.value    = "";
              adminReadInput.checked    = false;
              if (adminDateReadInput) setDateInputValue(adminDateReadInput, "");
              if (adminDateReadWrapper) adminDateReadWrapper.style.display = "none";
              adminCoverPreview.src     = "https://via.placeholder.com/150x220?text=No+Cover";
          }
         
           function openAdminForm(options) {
               const { mode, collection, book } = options;
         
               adminFormMode       = mode || "add";
               adminFormCollection = collection || "library";
               adminFormDocId      = book ? book.id : null;
         
               resetAdminForm();
         
               // Configure labels & visibility
               const isLibrary  = (adminFormCollection === "library");
               const isWishlist = (adminFormCollection === "wishlist");

               adminAmazonWrapper.style.display = isWishlist ? "flex" : "none";
               adminReadWrapper.style.display   = isLibrary  ? "block" : "none";
               if (adminDateReadWrapper) {
                 adminDateReadWrapper.style.display = isLibrary ? "block" : "none";
               }
         
               if (adminFormMode === "add") {
               adminFormTitle.textContent = isLibrary ? "Add Library Book" : "Add Wishlist Item";
               } else {
               adminFormTitle.textContent = isLibrary ? "Edit Library Book" : "Edit Wishlist Item";
               }
         
               // If editing, prefill
               if (book) {
               adminTitleInput.value     = book.Title || "";
               adminAuthorsInput.value   = book.Authors || "";
               adminPublisherInput.value = book.Publisher || "";
         
               // Only set date if it's already in a yyyy-mm-dd format
               const existingDate = (book.Date || "").trim();
               if (/^\d{4}-\d{2}-\d{2}$/.test(existingDate)) {
                 setDateInputValue(adminDateInput, existingDate);
               } else {
                 setDateInputValue(adminDateInput, "");
               }
         
               adminIsbnInput.value      = book.ISBN || "";
               adminCoverInput.value     = book.Cover || "";
               adminCoverPreview.src     = book.Cover || "https://via.placeholder.com/150x220?text=No+Cover";
         
               if (isWishlist) {
                   adminAmazonInput.value = book.AmazonURL || "";
               } else {
                   adminReadInput.checked = !!book.Read;
                   if (adminDateReadInput) {
                     const dr = (book.DateRead || "").trim();
                     setDateInputValue(adminDateReadInput, /^\d{4}-\d{2}-\d{2}$/.test(dr) ? dr : "");
                   }
                   if (adminDateReadWrapper) {
                     adminDateReadWrapper.style.display = adminReadInput.checked ? "block" : "none";
                   }
               }
               }
         
               // Ensure suggestions & multi-create button reflect the initial values
               renderTitleSuggestions();
               renderAuthorPublisherSuggestions();
               updateMultiCreateVisibility();
         
         
               adminFormOverlay.style.display = "flex";
           }
           
         multiEditorSaveAll.onclick = async () => {
         saveCurrentMultiCreateEntry();
         
           const col = adminFormCollection === "wishlist" ? "wishlist" : "library";
         
           try {
            for (const item of multiCreateItems) {
              const payload = {
              title: item.title,
              authors: item.authors,
              publisher: item.publisher,
              date: item.date,
              isbn: item.isbn,
              cover: item.cover
            };

            if (col === "wishlist") {
              payload.amazonURL = item.amazonURL || "";
            } else {
              payload.read = !!item.read;
              payload.dateRead = item.read
                ? (item.dateRead && /^\d{4}-\d{2}-\d{2}$/.test(item.dateRead)
                    ? item.dateRead
                    : new Date().toISOString().slice(0,10))
                : "";
            }
         
             if (item.existsAlready && item.docId) {
               // UPDATE existing doc
               await updateDoc(doc(db, col, item.docId), payload);
             } else {
               // ADD new doc
               await addDoc(collection(db, col), payload);
             }
           }
         
           multiEditorOverlay.style.display = "none";
           multiCreateActive = false;
           if (col === "wishlist") {
             await loadWishlistFromFirestore();
           } else {
             await loadLibraryFromFirestore();
           }
           addActivity(`Saved ${multiCreateItems.length} item(s) to ${col}`);
         } catch (err) {
           console.error("Multi-editor save error:", err);
           alert("Failed to save volumes. Check console for details.");
         }
         };
         
         multiEditorClose.onclick = () => {
           multiEditorOverlay.style.display = "none";
           multiCreateActive = false;
         };
         
          if (multiEditorAddVolume) {
            multiEditorAddVolume.onclick = () => {
              if (multiEditorMode !== 'series') return;
              saveCurrentMultiCreateEntry();
         
              // Find current max volume
              let maxVol = 0;
              for (const v of multiCreateVolumes) {
               if (v > maxVol) maxVol = v;
             }
             const newVol = maxVol + 1;
         
             // Just in case, avoid accidental duplicate
             if (multiCreateVolumes.includes(newVol)) {
               alert("That volume already exists in the list.");
               return;
             }
         
             const baseName = (currentSeriesSuggestion.displayName || currentSeriesSuggestion.baseName);
             const newItem = {
               title: `${baseName}, Vol. ${newVol}`,
               authors: currentSeriesSuggestion.author || "",
               publisher: currentSeriesSuggestion.publisher || "",
               date: "",
               isbn: "",
               cover: "",
               amazonURL: "",
               read: false,
               dateRead: "",
               vol: newVol,
               existsAlready: false,
               docId: null
             };
         
             // Keep arrays sorted by volume
             let insertIndex = multiCreateVolumes.findIndex(v => v > newVol);
             if (insertIndex === -1) insertIndex = multiCreateVolumes.length;
            
             multiCreateVolumes.splice(insertIndex, 0, newVol);
             multiCreateItems.splice(insertIndex, 0, newItem);
             multiCreateIndex = insertIndex;
         
             loadCurrentMultiCreateEntry();
           };
          }
         
           function closeAdminForm() {
               adminFormOverlay.style.display = "none";
           }
         
           adminCoverInput.addEventListener('input', () => {
               const url = adminCoverInput.value.trim();
               if (url && (url.startsWith("http://") || url.startsWith("https://"))) {
               adminCoverPreview.src = url;
               } else {
               adminCoverPreview.src = "https://via.placeholder.com/150x220?text=No+Cover";
               }
           });
           
           multiEditorCoverInput.addEventListener('input', () => {
               const url = multiEditorCoverInput.value.trim();
               if (url && (url.startsWith("http://") || url.startsWith("https://"))) {
                   multiEditorCoverPreview.src = url;
               } else {
                   multiEditorCoverPreview.src = "https://via.placeholder.com/150x220?text=No+Cover";
               }
           });
           
               adminFormClose.addEventListener('click', closeAdminForm);
               adminFormOverlay.addEventListener('click', (e) => {
                   if (e.target === adminFormOverlay) {
                   closeAdminForm();
                   }
               });
         
           adminFormSave.addEventListener('click', async () => {
               const title     = adminTitleInput.value.trim();
               const authors   = adminAuthorsInput.value.trim();
              const publisher = adminPublisherInput.value.trim();
              const date      = adminDateInput.value.trim();
              const isbn      = adminIsbnInput.value.trim();
              const cover     = adminCoverInput.value.trim();
              const amazonURL = adminAmazonInput.value.trim();
              const read      = adminReadInput.checked;
              const dateRead  = (adminDateReadInput && adminDateReadInput.value.trim()) || "";
              const editingExisting = (adminFormMode === "edit" && adminFormDocId);
              const editingCollection = adminFormCollection;
         
               if (!title) {
               alert("Title is required.");
               return;
               }
         
              try {
              if (adminFormMode === "add") {
                  if (adminFormCollection === "library") {
                  await addDoc(collection(db, "library"), {
                      title,
                      authors,
                      publisher,
                      date,
                      isbn,
                      cover,
                      read,
                      dateRead: read
                        ? (/^\d{4}-\d{2}-\d{2}$/.test(dateRead) ? dateRead : new Date().toISOString().slice(0,10))
                        : ""
                  });
                  addActivity(`Added "${title}" to library`);
                  } else {
                  await addDoc(collection(db, "wishlist"), {
                      title,
                      authors,
                       publisher,
                       date,
                       isbn,
                       cover,
                       amazonURL
                   });
                    addActivity(`Added "${title}" to wishlist`);
                   }
               } else if (adminFormMode === "edit" && adminFormDocId) {
                   const colName = adminFormCollection === "library" ? "library" : "wishlist";
                   const ref = doc(db, colName, adminFormDocId);
                  const payload = {
                  title,
                  authors,
                  publisher,
                  date,
                  isbn,
                  cover
                  };
                  if (colName === "library") {
                  payload.read = read;
                  payload.dateRead = read
                    ? (/^\d{4}-\d{2}-\d{2}$/.test(dateRead) ? dateRead : new Date().toISOString().slice(0,10))
                    : "";
                  } else {
                  payload.amazonURL = amazonURL;
                  }
                  await updateDoc(ref, payload);
                  addActivity(`Edited "${title}" in ${colName}`);
              }
         
               closeAdminForm();
               if (adminFormCollection === "wishlist") {
                 await loadWishlistFromFirestore();
               } else {
                 await loadLibraryFromFirestore();
               }

               const popupIsOpen = popupOverlay && popupOverlay.style.display === 'flex';
               if (editingExisting && popupIsOpen && currentPopupBook && currentPopupBook.id === adminFormDocId) {
                 const source = editingCollection === "wishlist" ? wishlistItems : libraryBooks;
                 const updated = source.find(b => b.id === adminFormDocId);
             if (updated) {
               showPopup(updated);
             }
           }
           } catch (err) {
           console.error(err);
           alert("Failed to save. Check console for details.");
           }
       });
         
         
         // expose some helpers to global (for safety if you need console access)
         window.searchLibrary = searchLibrary;
      </script>
   </body>
</html>
