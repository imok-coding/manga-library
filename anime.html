<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Tyler's Anime Library (MAL Synced)</title>
  <meta name="viewport" content="width=device-width, maximum-scale=1.0, user-scalable=no" />
  <meta name="theme-color" content="#1e0d14">

  <style>
    /* ===== BASE ===== */
    :root {
      --bg: #1e0d14;
      --bg-deep: #0b0610;
      --card-bg: #2b0f1d;
      --accent: #ff69b4;
      --accent-soft: rgba(255, 105, 180, 0.18);
      --accent-strong: rgba(255, 105, 180, 0.4);
      --text: #ffffff;
      --text-soft: #f8d1d8;
      --text-mute: #b58a9c;
      --border-soft: rgba(255, 182, 193, 0.25);
      --shadow-soft: 0 18px 45px rgba(0, 0, 0, 0.85);
      --radius-lg: 16px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      min-height: 100vh;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top left, #40202f 0, transparent 45%),
        radial-gradient(circle at bottom right, #120810 0, transparent 50%),
        #1e0d14;
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px 18px 40px;
      position: relative;
    }

    /* ===== HEADER ===== */
    header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 1.2rem;
    }

    header h1 {
      font-size: 1.5rem;
      color: #ffb6c1;
      text-shadow: 0 0 8px rgba(255, 182, 193, 0.7);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    header h1 span.badge {
      font-size: 0.75rem;
      padding: 2px 10px;
      border-radius: 999px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      background: rgba(255, 182, 193, 0.15);
      border: 1px solid rgba(255, 182, 193, 0.35);
      color: #ffb6c1;
    }

    .header-sub {
      font-size: 0.85rem;
      color: var(--text-soft);
    }

    .header-sub strong {
      color: #ffd1dc;
    }

    /* ===== TOOLBAR ===== */
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 1.2rem;
    }

    .toolbar-group {
      flex: 1;
      min-width: 220px;
      display: flex;
      gap: 0.5rem;
    }

    .toolbar input,
    .toolbar select {
      width: 100%;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: rgba(43, 15, 29, 0.93);
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
      box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5);
    }

    .toolbar input::placeholder {
      color: var(--text-mute);
    }

    /* ===== STATS BAR ===== */
    .stats-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-bottom: 1.4rem;
    }

    .stat-card {
      background: rgba(43, 15, 29, 0.95);
      border-radius: 14px;
      padding: 8px 10px;
      border: 1px solid var(--border-soft);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.85);
    }

    .stat-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-mute);
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 1.15rem;
      font-weight: 700;
      color: #ffffff;
    }

    .stat-sub {
      font-size: 0.75rem;
      color: var(--text-soft);
      margin-top: 1px;
    }

    /* ===== SKELETON LOADER ===== */
    .skeleton-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 18px;
      margin-top: 20px;
    }

    .skeleton-card {
      width: 100%;
      aspect-ratio: 2 / 3;
      border-radius: 16px;
      background: linear-gradient(
        110deg,
        rgba(255, 182, 193, 0.08) 0%,
        rgba(255, 182, 193, 0.18) 50%,
        rgba(255, 182, 193, 0.08) 100%
      );
      background-size: 200% 100%;
      animation: skeletonWave 1.4s ease-in-out infinite;
      box-shadow: 0 18px 35px rgba(0,0,0,0.65);
      border: 1px solid rgba(255,182,193,0.25);
    }

    @keyframes skeletonWave {
      from {
        background-position-x: 200%;
      }
      to {
        background-position-x: -200%;
      }
    }

    /* ===== GRID ===== */
    .anime-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 18px;
    }

    .anime-card {
      background: var(--card-bg);
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid rgba(255, 182, 193, 0.16);
      box-shadow: var(--shadow-soft);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      transition: transform 0.12s ease, box-shadow 0.15s ease, border-color 0.15s ease;
      content-visibility: auto;
      contain: content;
    }

    .anime-card:hover {
      transform: translateY(-4px) scale(1.01);
      border-color: var(--accent-soft);
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.95);
    }

    .anime-cover-wrap {
      position: relative;
      width: 100%;
      padding-top: 150%; /* 2:3 ratio */
      overflow: hidden;
      background: #3b1a28;
    }

    .anime-cover {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .badge-status {
      position: absolute;
      top: 6px;
      left: 6px;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.11em;
      color: #ffffff;
      background: rgba(0, 0, 0, 0.8);
    }

    .badge-status.watching { background: rgba(94, 222, 131, 0.9); }
    .badge-status.completed { background: rgba(96, 165, 250, 0.9); }
    .badge-status.on_hold { background: rgba(250, 204, 21, 0.9); }
    .badge-status.dropped { background: rgba(248, 113, 113, 0.95); }
    .badge-status.plan_to_watch { background: rgba(167, 139, 250, 0.95); }

    .badge-score {
      position: absolute;
      bottom: 6px;
      right: 6px;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: rgba(0, 0, 0, 0.85);
      color: #ffdd77;
      font-weight: 700;
    }

    .anime-meta {
      padding: 7px 8px 8px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .anime-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #ffc0cb;
      line-height: 1.3;
      max-height: 2.6em;
      overflow: hidden;
    }

    .anime-sub {
      font-size: 0.76rem;
      color: var(--text-soft);
    }

    .anime-progress {
      font-size: 0.78rem;
      color: var(--text-soft);
      margin-top: 2px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 1px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 182, 193, 0.35);
      background: rgba(43, 15, 29, 0.9);
      font-size: 0.72rem;
    }

    .pill-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
    }

    /* ===== LOADING / EMPTY / ERROR ===== */
    .loading {
      margin-top: 24px;
      font-size: 0.9rem;
      color: var(--text-soft);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .empty-state {
      margin-top: 30px;
      text-align: center;
      color: var(--text-soft);
      font-size: 0.9rem;
    }

    .empty-state strong {
      color: #ffb6c1;
    }

    .error-state {
      margin-top: 30px;
      text-align: center;
      font-size: 0.9rem;
      color: #ff9aa2;
    }

    /* ===== MODAL ===== */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(10, 2, 15, 0.92);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 16px;
    }

    .modal-backdrop.visible {
      display: flex;
    }

    .modal {
      max-width: 820px;
      width: 100%;
      max-height: 92vh;
      background: radial-gradient(circle at top left, #2b0f1d 0, #09040d 60%);
      border-radius: 20px;
      border: 1px solid rgba(255, 182, 193, 0.35);
      box-shadow: 0 26px 70px rgba(0, 0, 0, 0.95);
      overflow: hidden;
      display: grid;
      grid-template-columns: minmax(0, 1.3fr) minmax(0, 2fr);
    }

    @media (max-width: 800px) {
      .modal {
        grid-template-columns: 1fr;
        max-height: 94vh;
      }
    }

    .modal-cover-wrap {
      position: relative;
      background: #000;
      min-height: 260px;
    }

    .modal-cover-wrap img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .modal-body {
      padding: 10px 12px 12px;
      overflow: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 6px;
    }

    .modal-title {
      font-size: 1.05rem;
      font-weight: 600;
      color: #ffb6c1;
    }

    .modal-close {
      border: none;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-soft);
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .modal-close:hover {
      background: rgba(255, 255, 255, 0.16);
      color: #ffffff;
    }

    .modal-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 6px;
    }

    .modal-tag {
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-soft);
    }

    .modal-section {
      margin-bottom: 7px;
      font-size: 0.82rem;
    }

    .modal-section h3 {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-mute);
      margin-bottom: 3px;
    }

    .modal-section p {
      line-height: 1.5;
      color: var(--text-soft);
    }

    .modal-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      margin-top: 6px;
      font-size: 0.76rem;
      color: var(--text-mute);
      flex-wrap: wrap;
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .chip {
      padding: 2px 7px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
    }

    .chip-accent {
      background: var(--accent-soft);
      color: var(--accent);
      border: 1px solid var(--accent-strong);
    }

    /* ===== BACK BUTTON ===== */
    .back-button {
    position: fixed;
    top: 16px;
    left: 16px;
    z-index: 3000;
    
    display: inline-flex;
    align-items: center;
    gap: 6px;

    padding: 8px 14px;
    border-radius: 999px;

    font-size: 0.9rem;
    font-weight: 600;

    color: #ffb6c1;
    background: rgba(43, 15, 29, 0.75);
    border: 1px solid rgba(255, 182, 193, 0.3);

    text-decoration: none;
    cursor: pointer;

    box-shadow: 0 10px 24px rgba(0,0,0,0.45);
    backdrop-filter: blur(6px);

    transition: all 0.25s ease;
    }

    .back-button:hover {
    background: rgba(255, 105, 180, 0.25);
    border-color: rgba(255, 182, 193, 0.5);
    transform: translateX(-3px);
    }

    /* Scrollbars */
    * {
      scrollbar-width: thin;
      scrollbar-color: #ff69b4 #1e0d14;
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #1e0d14;
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, #ff69b4 0%, #c2185b 100%);
      border-radius: 10px;
      border: 1px solid #2b0f1d;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, #ffc0cb 0%, #ff69b4 100%);
    }

    @media (max-width: 600px) {
      body {
        background-attachment: scroll;
        padding-bottom: 16px;
      }
      .page {
        padding: 14px 12px 26px;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <a href="index.html" class="back-button">
        &#10094; Back
    </a>

    <header>
      <div>
        <h1>
          Tyler's Anime Library
          <span class="badge">MAL synced</span>
        </h1>
        <div class="header-sub">
          Source: MyAnimeList user <strong>im_ok</strong> · Managed entirely on MAL
        </div>
      </div>
      <div class="header-sub">
        No add/remove here – this page is a read-only mirror of your MAL list.
      </div>
    </header>

    <!-- Toolbar (search + status filter) -->
    <div class="toolbar">
      <div class="toolbar-group">
        <input id="searchInput" type="text" placeholder="Search anime by title…" autocomplete="off" />
      </div>
      <div class="toolbar-group" style="max-width: 230px;">
        <select id="statusFilter">
          <option value="all">All statuses</option>
          <option value="watching">Watching</option>
          <option value="completed">Completed</option>
          <option value="on_hold">On Hold</option>
          <option value="dropped">Dropped</option>
          <option value="plan_to_watch">Plan to Watch</option>
        </select>
      </div>
    </div>

    <!-- Stats -->
    <div id="statsBar" class="stats-bar"></div>

    <!-- Skeleton Loader -->
    <div id="skeletonLoader" class="skeleton-grid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>

    <!-- Legacy loading text (hidden + removed later) -->
    <div id="loadingState" class="loading" hidden>
      <span>Loading anime list from MyAnimeList…</span>
    </div>

    <!-- Error / Empty / Grid -->
    <div id="errorState" class="error-state" hidden>
      Could not load data from MAL through the proxy. Check your Worker is deployed and the Client ID inside it is valid.
    </div>

    <div id="animeGrid" class="anime-grid" hidden></div>

    <div id="emptyState" class="empty-state" hidden>
      No anime found. Try changing your <strong>search</strong> or <strong>status</strong> filter.
    </div>
  </div>

  <!-- Modal -->
  <div id="modalBackdrop" class="modal-backdrop">
    <div class="modal">
      <div class="modal-cover-wrap">
        <img id="modalCover" src="" alt="Anime cover" />
      </div>
      <div class="modal-body">
        <div class="modal-header">
          <div class="modal-title" id="modalTitle"></div>
          <button class="modal-close" id="modalCloseBtn">Close</button>
        </div>

        <div class="modal-tags" id="modalTags"></div>

        <div class="modal-section">
          <h3>Synopsis</h3>
          <p id="modalSynopsis"></p>
        </div>

        <div class="modal-section">
          <h3>Details</h3>
          <p id="modalDetails"></p>
        </div>

        <div class="modal-footer">
          <div class="chip-row" id="modalChips"></div>
          <div id="modalFooterRight"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- JS -->
  <script>
    // ===== CONFIG =====
    const MAL_USERNAME   = "im_ok";
    const MAL_API_BASE   = "https://api.myanimelist.net/v2";
    const PROXY_BASE_URL = "https://imokmalworker.imokissick.workers.dev/"; // your Worker

    const STATUS_LIST = [
      "watching",
      "completed",
      "on_hold",
      "dropped",
      "plan_to_watch"
    ];

    let allAnime = [];
    let filteredAnime = [];

    // DOM
    const searchInput   = document.getElementById("searchInput");
    const statusFilter  = document.getElementById("statusFilter");
    const animeGrid     = document.getElementById("animeGrid");
    const statsBar      = document.getElementById("statsBar");
    const loadingState  = document.getElementById("loadingState");
    const emptyState    = document.getElementById("emptyState");
    const errorState    = document.getElementById("errorState");
    const skeletonLoader= document.getElementById("skeletonLoader");

    const modalBackdrop   = document.getElementById("modalBackdrop");
    const modalCover      = document.getElementById("modalCover");
    const modalTitle      = document.getElementById("modalTitle");
    const modalTags       = document.getElementById("modalTags");
    const modalSynopsis   = document.getElementById("modalSynopsis");
    const modalDetails    = document.getElementById("modalDetails");
    const modalChips      = document.getElementById("modalChips");
    const modalFooterRight= document.getElementById("modalFooterRight");
    const modalCloseBtn   = document.getElementById("modalCloseBtn");

    // ===== HELPERS =====
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function formatStatus(status) {
      switch (status) {
        case "watching":      return "Watching";
        case "completed":     return "Completed";
        case "on_hold":       return "On Hold";
        case "dropped":       return "Dropped";
        case "plan_to_watch": return "Plan to Watch";
        default:              return status;
      }
    }

    function formatDate(iso) {
      if (!iso) return "Unknown";
      const d = new Date(iso);
      if (isNaN(d.getTime())) return "Unknown";
      return d.toLocaleDateString(undefined, {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    }

    function showSkeleton() {
      if (skeletonLoader) skeletonLoader.hidden = false;
      if (loadingState) {
        loadingState.hidden = false;
        loadingState.style.display = "flex";
      }
      animeGrid.hidden = true;
    }

    function hideSkeleton() {
      if (skeletonLoader) skeletonLoader.remove();
      if (loadingState) {
        loadingState.hidden = true;
        loadingState.style.display = "none";
      }
    }

    async function proxyFetchJson(url) {
      const full = PROXY_BASE_URL + "?url=" + encodeURIComponent(url);
      const res = await fetch(full);
      if (!res.ok) {
        throw new Error("Proxy/MAL error: " + res.status);
      }
      return res.json();
    }

    // ===== API (MAL v2 through proxy) =====
    async function fetchMalAnimeByStatus(status) {
      const baseUrl =
        `${MAL_API_BASE}/users/${encodeURIComponent(MAL_USERNAME)}` +
        `/animelist?status=${encodeURIComponent(status)}` +
        `&limit=1000&fields=` +
        [
          "list_status",
          "mean",
          "num_episodes",
          "media_type",
          "main_picture",
          "start_date",
          "end_date",
          "synopsis",
          "start_season",
          "genres",
          "studios"
        ].join(",");

      let all = [];
      let nextUrl = baseUrl;
      let pageGuard = 0;

      while (nextUrl && pageGuard < 5) {
        const json = await proxyFetchJson(nextUrl);
        const data = Array.isArray(json.data) ? json.data : [];
        all = all.concat(data);

        if (json.paging && json.paging.next) {
          nextUrl = json.paging.next;
          pageGuard += 1;
          await sleep(500);
        } else {
          nextUrl = null;
        }
      }

      return all.map(entry => {
        const node = entry.node || {};
        const list = entry.list_status || {};

        const picture = node.main_picture || {};
        const coverUrl = picture.large || picture.medium || "";

        return {
          id: node.id,
          title: node.title || "Unknown title",
          cover: coverUrl,
          type: node.media_type || "Anime",
          episodes: typeof node.num_episodes === "number"
            ? node.num_episodes
            : null,
          score: typeof list.score === "number" ? list.score : 0,
          status: (list.status || status).toLowerCase(),
          episodes_watched:
            list.num_episodes_watched != null
              ? list.num_episodes_watched
              : 0,
          start_date: list.start_date || node.start_date || null,
          end_date: list.finish_date || list.end_date || node.end_date || null,
          synopsis: node.synopsis || "No synopsis available.",
          season: node.start_season?.season || "",
          year: node.start_season?.year || null,
          genres: Array.isArray(node.genres)
            ? node.genres.map(g => g.name)
            : [],
          studios: Array.isArray(node.studios)
            ? node.studios.map(s => s.name)
            : [],
          mean_score: node.mean != null ? node.mean : null
        };
      });
    }

    async function loadAllAnime() {
      let combined = [];
      for (const status of STATUS_LIST) {
        const chunk = await fetchMalAnimeByStatus(status);
        combined = combined.concat(chunk);
        await sleep(400);
      }
      return combined;
    }

    // ===== RENDERING =====
    function renderStats(list) {
      if (!list.length) {
        statsBar.innerHTML = "";
        return;
      }

      const counts = {
        watching: 0,
        completed: 0,
        on_hold: 0,
        dropped: 0,
        plan_to_watch: 0
      };
      let totalEpisodesWatched = 0;

      for (const item of list) {
        if (counts[item.status] != null) {
          counts[item.status]++;
        }
        totalEpisodesWatched += item.episodes_watched || 0;
      }

      const totalAnime = list.length;
      const totalHours = totalEpisodesWatched * 0.5; // ~24min per episode

      statsBar.innerHTML = `
        <div class="stat-card">
          <div class="stat-label">Total Anime</div>
          <div class="stat-value">${totalAnime}</div>
          <div class="stat-sub">
            Watching: ${counts.watching || 0} · Completed: ${counts.completed || 0}
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Episodes Watched</div>
          <div class="stat-value">${totalEpisodesWatched}</div>
          <div class="stat-sub">
            ~${Math.round(totalHours)} hours of anime
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Backlog</div>
          <div class="stat-value">${(counts.plan_to_watch || 0) + (counts.on_hold || 0)}</div>
          <div class="stat-sub">
            Plan to watch: ${counts.plan_to_watch || 0} · On hold: ${counts.on_hold || 0}
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Dropped</div>
          <div class="stat-value">${counts.dropped || 0}</div>
          <div class="stat-sub">
            Sometimes it just be like that.
          </div>
        </div>
      `;
    }

    function renderGrid(list) {
      animeGrid.innerHTML = "";

      if (!list.length) {
        animeGrid.hidden = true;
        emptyState.hidden = false;
        return;
      }

      animeGrid.hidden = false;
      emptyState.hidden = true;

      for (const item of list) {
        const scoreText = item.score ? item.score.toFixed(1) : "–";
        const progress =
          item.episodes && item.episodes > 0
            ? `${item.episodes_watched}/${item.episodes} ep`
            : `${item.episodes_watched} ep`;

        const yearText = item.year ? item.year : "";
        const typeLabel = item.type || "Anime";

        const card = document.createElement("article");
        card.className = "anime-card";
        card.dataset.id = String(item.id);

        card.innerHTML = `
          <div class="anime-cover-wrap">
            <img
              class="anime-cover"
              src="${item.cover}"
              alt="${item.title}"
              loading="lazy"
            />
            <div class="badge-status ${item.status}">
              ${formatStatus(item.status)}
            </div>
            <div class="badge-score">
              ★ ${scoreText}
            </div>
          </div>
          <div class="anime-meta">
            <div class="anime-title" title="${item.title}">
              ${item.title}
            </div>
            <div class="anime-sub">
              ${typeLabel}${yearText ? " • " + yearText : ""}
            </div>
            <div class="anime-progress">
              <span class="pill">
                <span class="pill-dot"></span>
                ${progress}
              </span>
            </div>
          </div>
        `;

        card.addEventListener("click", () => openModal(item));
        animeGrid.appendChild(card);
      }
    }

    function applyFilters() {
      const q = searchInput.value.trim().toLowerCase();
      const status = statusFilter.value;

      filteredAnime = allAnime.filter(item => {
        const matchesTitle = item.title.toLowerCase().includes(q);
        const matchesStatus = status === "all" ? true : item.status === status;
        return matchesTitle && matchesStatus;
      });

      renderStats(filteredAnime);
      renderGrid(filteredAnime);
    }

    // ===== MODAL =====
    function openModal(item) {
      modalCover.src = item.cover || "";
      modalTitle.textContent = item.title;
      modalTags.innerHTML = "";

      if (item.type) {
        const t = document.createElement("span");
        t.className = "modal-tag";
        t.textContent = item.type.toUpperCase();
        modalTags.appendChild(t);
      }
      if (item.status) {
        const t = document.createElement("span");
        t.className = "modal-tag";
        t.textContent = formatStatus(item.status);
        modalTags.appendChild(t);
      }
      if (item.season || item.year) {
        const t = document.createElement("span");
        t.className = "modal-tag";
        t.textContent = `${item.season ? item.season[0].toUpperCase() + item.season.slice(1) : ""}${item.year ? " " + item.year : ""}`;
        modalTags.appendChild(t);
      }

      modalSynopsis.textContent = item.synopsis || "No synopsis available.";

      const detailsLines = [];
      detailsLines.push(
        `Episodes watched: ${item.episodes_watched}${
          item.episodes ? " / " + item.episodes : ""
        }`
      );

      if (item.start_date || item.end_date) {
        detailsLines.push(
          `Started: ${formatDate(item.start_date)} · Finished: ${formatDate(
            item.end_date
          )}`
        );
      }

      if (item.studios && item.studios.length) {
        detailsLines.push(`Studios: ${item.studios.join(", ")}`);
      }

      modalDetails.innerHTML = detailsLines.join("<br>");

      modalChips.innerHTML = "";
      if (item.score) {
        const chip = document.createElement("span");
        chip.className = "chip chip-accent";
        chip.textContent = `Your score: ${item.score.toFixed(1)}`;
        modalChips.appendChild(chip);
      }

      if (item.mean_score != null) {
        const chip = document.createElement("span");
        chip.className = "chip";
        chip.textContent = `MAL mean: ${item.mean_score.toFixed(1)}`;
        modalChips.appendChild(chip);
      }

      if (item.genres && item.genres.length) {
        for (const g of item.genres.slice(0, 6)) {
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.textContent = g;
          modalChips.appendChild(chip);
        }
      }

      modalFooterRight.textContent = item.status === "watching"
        ? "Currently on your Watching list"
        : `Status: ${formatStatus(item.status)}`;

      modalBackdrop.classList.add("visible");
    }

    function closeModal() {
      modalBackdrop.classList.remove("visible");
    }

    modalBackdrop.addEventListener("click", (e) => {
      if (e.target === modalBackdrop) closeModal();
    });
    modalCloseBtn.addEventListener("click", closeModal);
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeModal();
    });

    // ===== INIT =====
    async function init() {
      showSkeleton();
      errorState.hidden = true;
      emptyState.hidden = true;
      animeGrid.hidden = true;

      let raw;
      try {
        raw = await loadAllAnime();
      } catch (err) {
        console.error("Global MAL load error", err);
        hideSkeleton();
        errorState.hidden = false;
        return;
      }

      allAnime = raw.slice();
      hideSkeleton();

      if (!allAnime.length) {
        renderStats([]);
        renderGrid([]);
        return;
      }

      filteredAnime = allAnime.slice();
      renderStats(filteredAnime);
      renderGrid(filteredAnime);

      searchInput.addEventListener("input", applyFilters);
      statusFilter.addEventListener("change", applyFilters);
    }

    init();
  </script>
</body>
</html>
